# تابع فیبوناچی

این مخزن پیاده‌سازی‌های مختلف تابع فیبوناچی را در چندین زبان برنامه‌نویسی ارائه می‌دهد. می‌توانید زبان مورد نظر خود را برای مشاهده محتوا انتخاب کنید.

#### زبان‌های برنامه‌نویسی:
[Python](/fibonacci/python/) | [C#](/fibonacci/C#/) | [JavaScript](/fibonacci/javascript/) | [C++](/fibonacci/C++/) | [Java](/fibonacci/javascript/)

<br />

#### زبان‌های موجود:
[English](/fibonacci/README.md) 

<br />

## ℹ️ فیبوناچی چیست؟
دنباله **فیبوناچی** دنباله‌ای از اعداد است که در آن هر عدد برابر با جمع دو عدد قبلی خود است، و معمولاً با صفر و یک شروع می‌شود. این دنباله به این صورت است:  
`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

<br />

#### 📐 تعریف ریاضی:
$$
F(0) = 0,\ F(1) = 1
$$
$$
F(n) = F(n - 1) + F(n - 2)\ \text{برای}\ n > 1
$$

<br />

#### 🔢 مثال:
$$
F(0) = 0,\ F(1) = 1,\ F(2) = 1,\ F(3) = 2,\ F(4) = 3,\ F(5) = 5,\ F(6) = 8
$$

<br />

## 🧩 کاربردهای دنباله فیبوناچی

 ◻️ **زیست‌شناسی**: ظهور در الگوهای طبیعی مانند شاخه‌بندی درختان، آرایش برگ‌ها (فیلوتاکسی) و رشد جمعیت زنبورها.

◻️ **هنر و طراحی**: ارتباط تنگاتنگ با نسبت طلایی که در معماری، طراحی گرافیک و عکاسی استفاده می‌شود.
 
 ◻️ **اقتصاد و مالی**: استفاده در تحلیل تکنیکال بازارهای مالی از طریق سطوح بازگشت فیبوناچی.

<br />

## 🎯 هدف این مخزن

هدف این پروژه این است که پیاده‌سازی‌های مختلف تابع فیبوناچی را در زبان‌های برنامه‌نویسی مختلف و با رویکردهای متنوع نشان دهد، از جمله:

◻️​​ روش بازگشتی (Recursive)

◻️​ روش تکراری (Iterative)

◻️ مموریزیشن / برنامه‌نویسی پویا (Memoization / Dynamic Programming)

◻️ الگوریتم‌های بهینه (مانند به توان رساندن ماتریس یا Fast Doubling)

### 📊 مقایسه روش‌های محاسبه فیبوناچی

| روش                         | پیچیدگی زمانی   | پیچیدگی فضایی   | توضیحات |
|:----:|:----:|:----:|:----:|
| **بازگشتی (Recursive)**           | O(2ⁿ)            | O(n)              | ساده اما بسیار کند. برای مقادیر بزرگ `n` مناسب نیست. |
| **تکراری (Iterative)**            | O(n)             | O(1)              | سریع و بهینه در مصرف حافظه. برای اکثر موارد مناسب است. |
| **ذخیره‌سازی (Memoization)**      | O(n)             | O(n)              | بازگشتی را با ذخیره‌سازی مقادیر بهتر می‌کند. برای چندین فراخوانی مفید است. |
| **به توان رساندن ماتریس (Matrix Exponentiation)** | O(log n)     | O(log n)          | برای مقادیر بزرگ `n` بسیار سریع. از روش دوگانه کردن استفاده می‌کند. |
| **دوبل‌سازی سریع (Fast Doubling)**    | O(log n)         | O(log n)         | مشابه ماتریس، اما معمولاً کمی سریع‌تر. از هویت‌های ریاضی استفاده می‌کند. |