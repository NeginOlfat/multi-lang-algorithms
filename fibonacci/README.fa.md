# تابع فیبوناچی

این مخزن پیاده‌سازی‌های مختلف تابع فیبوناچی را در چندین زبان برنامه‌نویسی ارائه می‌دهد. می‌توانید زبان مورد نظر خود را برای مشاهده محتوا انتخاب کنید.

#### زبان‌های برنامه‌نویسی:
[Python](/fibonacci/python/) | [C#](/fibonacci/csharp/) | [JavaScript](/fibonacci/javascript/) | [C++](/fibonacci/C++/) | [Java](/fibonacci/javascript/)

<br />

#### زبان‌های موجود:
[English](/fibonacci/README.md) 

<br />

## ℹ️ فیبوناچی چیست؟
دنباله **فیبوناچی** دنباله‌ای از اعداد است که در آن هر عدد برابر با جمع دو عدد قبلی خود است، و معمولاً با صفر و یک شروع می‌شود. این دنباله به این صورت است:  
$$
 ‭0, 1, 1, 2, 3, 5, 8, 13, 21, ..‬
$$
<br />

#### 📐 تعریف ریاضی:
$$
F(0) = 0,\ F(1) = 1
$$
$$
F(n) = F(n - 1) + F(n - 2)\ \text{برای}\ n > 1
$$

<br />

#### 🔢 مثال:
$$
F(0) = 0,\ F(1) = 1,\ F(2) = 1,\ F(3) = 2,\ F(4) = 3,\ F(5) = 5,\ F(6) = 8
$$

<br />

## 🧩 کاربردهای دنباله فیبوناچی

 ◻️ **زیست‌شناسی**: ظهور در الگوهای طبیعی مانند شاخه‌بندی درختان، آرایش برگ‌ها (فیلوتاکسی) و رشد جمعیت زنبورها.

◻️ **هنر و طراحی**: ارتباط تنگاتنگ با نسبت طلایی که در معماری، طراحی گرافیک و عکاسی استفاده می‌شود.
 
 ◻️ **اقتصاد و مالی**: استفاده در تحلیل تکنیکال بازارهای مالی از طریق سطوح بازگشت فیبوناچی.

<br />

## 🎯 هدف این مخزن

هدف این پروژه این است که پیاده‌سازی‌های مختلف تابع فیبوناچی را در زبان‌های برنامه‌نویسی مختلف و با رویکردهای متنوع نشان دهد، از جمله:

◻️​​ روش بازگشتی (Recursive)

◻️​ روش تکراری (Iterative)

◻️ مموریزیشن / برنامه‌نویسی پویا (Memoization / Dynamic Programming)

◻️ الگوریتم‌های بهینه (مانند به توان رساندن ماتریس یا Fast Doubling)

### 📊 مقایسه روش‌های محاسبه فیبوناچی

| توضیحات | پیچیدگی فضایی   | پیچیدگی زمانی   | روش                         |
|----:|:----:|:----:|----:|
| ساده است اما بسیار کند و برای مقادیر بزرگ مناسب نیست. | O(n)              | O(2ⁿ)            | **بازگشتی (Recursive)**           |
| در مصرف حافظه سریع و بهینه است و برای اکثر موارد مناسب است. | O(1)              | O(n)             | **تکراری (Iterative)**            |
| بازگشتی را با ذخیره‌سازی مقادیر بهتر می‌کند و برای چندین فراخوانی مفید است. | O(n)              | O(n)             | **ذخیره‌سازی (Memoization)**      |
| برای مقادیر بزرگ بسیار سریع است و از روش دوگانه کردن استفاده می‌کند. | O(log n)          | O(log n)     | **به توان رساندن ماتریس (Matrix Exponentiation)** |
| مشابه ماتریس، اما معمولاً کمی سریع‌تر است از هویت‌های ریاضی استفاده می‌کند. | O(log n)         | O(log n)         | **دوبل‌سازی سریع (Fast Doubling)**    |
