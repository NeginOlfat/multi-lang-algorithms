# 🧠 توضیح کد فیبوناچی به زبان C#

## 📌 روش بازگشتی (Recursive)

```csharp
public static int FibonacciRecursive(int n)
{
    // حالت پایه: اگر n کوچکتر یا مساوی 0 باشد، 0 برگردانده شود
    if (n <= 0)
        return 0;
    // حالت پایه: اگر n برابر با 1 باشد، 1 برگردانده شود
    else if (n == 1)
        return 1;
    // حالت بازگشتی
    else
        return FibonacciRecursive(n - 1) + FibonacciRecursive(n - 2);
}
```
این روش از یک رویکرد بازگشتی (Recursion) ساده استفاده می‌کند که در آن تابع خود را دوباره فراخوانی می‌کند تا دو عدد قبلی را محاسبه کند. این روش دارای پیچیدگی زمانی بالایی است (O(2ⁿ)) چون مقادیر تکراری بارها محاسبه می‌شوند.

<br />

## 📌 روش تکراری (Iterative)
```csharp
public static int FibonacciIterative(int n)
{
    // حالت‌های پایه
    if (n <= 0)
        return 0;
    if (n == 1)
        return 1;

    int a = 0, b = 1;
    for (int i = 2; i <= n; i++)
    {
        int temp = b;
        b = a + b;
        a = temp;
    }
    return b;
}
```
این روش از یک حلقه برای محاسبه اعداد فیبوناچی استفاده می‌کند. به جای فراخوانی‌های متعدد بازگشتی، تنها از دو متغیر برای ذخیره دو عدد قبلی استفاده می‌شود. این روش بسیار کارآمدتر است و دارای پیچیدگی زمانی خطی O(n) و پیچیدگی فضایی ثابت O(1) می‌باشد.

<br />

## 📌 روش مموریزیشن / ذخیره‌سازی (Memoization)
```csharp
public static int FibonacciMemoization(int n, Dictionary<int, int> memo = null)
{
    memo ??= new Dictionary<int, int>(); // اگر memo تهی باشد، یک دیکشنری جدید ایجاد کن

    if (memo.ContainsKey(n))
        return memo[n];

    // حالت‌های پایه
    if (n <= 0)
        return 0;
    if (n == 1)
        return 1;

    // نتیجه را در memo ذخیره کن تا محاسبات تکراری انجام نشود
    memo[n] = FibonacciMemoization(n - 1, memo) + FibonacciMemoization(n - 2, memo);
    return memo[n];
}
```
این روش از ذخیره‌سازی مقادیر قبلی (Memoization) استفاده می‌کند تا از محاسبات تکراری جلوگیری کند. با استفاده از یک دیکشنری (Dictionary) نتایج را ذخیره کرده و در صورت نیاز دوباره استفاده می‌کند. این کار پیچیدگی زمانی را از O(2ⁿ) به O(n) کاهش می‌دهد و عملکرد برنامه را به میزان قابل توجهی بهبود می‌بخشد.

<br/>

## 📌 روش به توان رساندن ماتریس (Matrix Exponentiation)
```csharp   
public static int FibonacciMatrix(int n)
{
    // حالت پایه: فیبوناچی عدد 0 برابر با 0 است
    if (n <= 0)
        return 0;

    // تعریف یک ماتریس ۲×۲
    int[,] Multiply(int[,] a, int[,] b)
    {
        // مقداردهی اولیه ماتریس خروجی با صفر
        int[,] c = new int[2, 2];

        // ضرب دستی دو ماتریس ۲×۲
        for (int i = 0; i < 2; i++)
        {
            for (int j = 0; j < 2; j++)
            {
                // هر عنصر، حاصل ضرب سطر i از a در ستون j از b است
                c[i, j] = a[i, 0] * b[0, j] + a[i, 1] * b[1, j];
            }
        }

        return c;
    }

    // تابع بازگشتی برای محاسبه ماتریس به توان n
    int[,] Power(int[,] mat, int n)
    {
        if (n == 1)
            return mat;

        int[,] half = Power(mat, n / 2);
        int[,] sq = Multiply(half, half);

        if (n % 2 == 0)
            return sq;
        else
            return Multiply(sq, new int[,] { { 1, 1 }, { 1, 0 } });
    }

    // شروع با ماتریس [[1,1],[1,0]]^n-1
    int[,] result = Power(new int[,] { { 1, 1 }, { 1, 0 } }, n - 1);

    // عدد فیبوناچی در خانه بالا-چپ ماتریس قرار دارد
    return result[0, 0];
}  
```
این روش از به توان رساندن ماتریس برای محاسبه عدد n-ام فیبوناچی به شیوه‌ای کارآمد استفاده می‌کند. این روش از هویت زیر استفاده می‌کند:

$$
\begin{bmatrix}
F(n+1) & F(n) \\
F(n) & F(n-1)
\end{bmatrix}
=
\begin{bmatrix}
1 & 1 \\
1 & 0
\end{bmatrix}^n
$$

برای یافتن `F(n)`:

◻️​ماتریس تبدیل `[[1, 1], [1, 0]]` را به توان `n - 1` برسانید.

◻️عنصر اول ماتریس حاصل (F(n)) را برگردانید.


### ✅ چرا این روش کارآمد است:
◻️ از به توان رساندن دوگانه استفاده می‌کند.

◻️ پیچیدگی زمانی را به O(log n) کاهش می‌دهد.

◻️ از محاسبات تکراری جلوگیری می‌کند.

<br/>

## 📌 روش دوبل‌سازی سریع (Fast Doubling)
```csharp
public static int FibonacciFastDoubling(int n)
{
    // تابع کمکی بازگشتی که زوج [F(k), F(k+1)] را برمی‌گرداند
    (int, int) FastDbl(int k)
    {
        // حالت پایه: F(0)=0, F(1)=1
        if (k == 0)
            return (0, 1);

        var (a, b) = FastDbl(k / 2);

        // استفاده از هویت‌ها:
        // F(2k)   = F(k) * [2*F(k+1) - F(k)]
        // F(2k+1) = F(k+1)^2 + F(k)^2
        int c = a * (2 * b - a); // F(2k)
        int d = a * a + b * b;     // F(2k+1)

        if (k % 2 == 0)
            return (c, d); // اگر k زوج باشد
        else
            return (d, c + d); // اگر k فرد باشد
    }

    return FastDbl(n).Item1; // بازگرداندن F(n)
}
```
این روش از هویت‌های ریاضی فیبوناچی برای محاسبه سریع استفاده می‌کند:

- $ F(2k) = F(k) \cdot (2F(k+1) - F(k)) $
- $ F(2k + 1) = F(k+1)^2 + F(k)^2 $

تابع به صورت بازگشتی `[F(k), F(k+1)]` را محاسبه کرده و بر اساس اینکه `n` زوج یا فرد است، مقادیر را ترکیب می‌کند.

### ✅ چرا این روش کارآمد است:

◻️ محاسبه F(n) را در O(log n) انجام می‌دهد.

◻️ در هر مرحله دو مقدار را برمی‌گرداند تا از محاسبه 
مجدد جلوگیری شود.

◻️ به طور کلی نسبت به روش ماتریس سریع‌تر است زیرا عملیات کمتری انجام می‌دهد.
