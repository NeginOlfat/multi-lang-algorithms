# 🧠 توضیح کد فیبوناچی به زبان JavaScript

## 📌 روش بازگشتی (Recursive)

```javascript
function fibonacciRecursive(n) {
    // حالت‌های پایه
    if (n <= 0) return 0;
    if (n === 1) return 1;

    // حالت بازگشتی
    return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
}
```

این روش از یک رویکرد بازگشتی (Recursion) ساده استفاده می‌کند که در آن تابع خود را دوباره فراخوانی می‌کند تا دو عدد قبلی را محاسبه کند. این روش دارای پیچیدگی زمانی بالا به دلیل محاسبات تکراری بسیار زیاد است و زمان اجرای آن به صورت نمایی O(2ⁿ) می‌باشد.

<br />

## 📌 روش تکراری (Iterative)
```javascript 
function fibonacciIterative(n) {
    // حالت‌های پایه
    if (n <= 0) return 0;
    if (n === 1) return 1;

    let a = 0, b = 1;
    for (let i = 2; i <= n; i++) {
        [a, b] = [b, a + b]; // به‌روزرسانی a و b
    }
    return b;
}
```

این روش از یک حلقه برای محاسبه اعداد فیبوناچی به صورت غیر بازگشتی استفاده می‌کند. این روش کارآمدتر از روش بازگشتی است زیرا از بار اضافی فراخوانی‌های چندگانه تابع جلوگیری می‌کند و دارای پیچیدگی زمانی خطی O(n) است.

<br />

## 📌 روش مموریزیشن / ذخیره‌سازی (Memoization)
```javascript
function fibonacciMemoization(n, memo = {}) {
    // اگر قبلاً محاسبه شده باشد، مقدار را برگردان
    if (memo[n] !== undefined) return memo[n];

    // حالت‌های پایه
    if (n <= 0) return 0;
    if (n === 1) return 1;

    // ذخیره نتیجه برای جلوگیری از محاسبه مجدد
    memo[n] = fibonacciMemoization(n - 1, memo) + fibonacciMemoization(n - 2, memo);
    return memo[n];
}
```
این روش از ذخیره‌سازی مقادیر قبلی (Memoization) استفاده می‌کند تا از محاسبات تکراری جلوگیری کند. با استفاده از یک شیء (memo) نتایج را ذخیره کرده و در صورت نیاز دوباره استفاده می‌کند. این کار پیچیدگی زمانی را از O(2ⁿ) به O(n) کاهش می‌دهد و عملکرد برنامه را به میزان قابل توجهی بهبود می‌بخشد.


<br/>

## 📌 روش به توان رساندن ماتریس (Matrix Exponentiation)
```javascript
function fibonacciMatrix(n) {
    // حالت پایه: فیبوناچی عدد 0 برابر با 0 است
    if (n <= 0) return 0;

    // تابع ضرب دو ماتریس ۲×۲
    function multiply(a, b) {
        // مقداردهی اولیه ماتریس خروجی با صفر
        const c = [[0, 0], [0, 0]];

        // انجام ضرب دستی برای ماتریس‌های ۲×۲
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 2; j++) {
                // هر عنصر، حاصل ضرب سطر i از ماتریس a و ستون j از ماتریس b است
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
            }
        }

        // بازگرداندن ماتریس حاصل
        return c;
    }

    // تابع بازگشتی برای محاسبه ماتریس به توان n با استفاده از به توان رساندن دوگانه
    function power(mat, n) {
        // حالت پایه: ماتریس به توان ۱ خودش است
        if (n === 1) return mat;

        // محاسبه به توان رساندن ماتریس برای n/2
        const half = power(mat, Math.floor(n / 2));

        // مجذور کردن نتیجه
        const sq = multiply(half, half);

        // اگر n فرد باشد، یک بار دیگر در ماتریس اصلی ضرب کن
        return n % 2 === 0 ? sq : multiply(sq, [[1, 1], [1, 0]]);
    }

    // شروع با ماتریس تبدیل [[1,1],[1,0]] و به توان رساندن آن به اندازه (n - 1)
    const result = power([[1, 1], [1, 0]], n - 1);

    // عدد فیبوناچی، عنصر اول ماتریس حاصل است
    return result[0][0];
}
```
این روش از به توان رساندن ماتریس برای محاسبه عدد n-ام فیبوناچی به شیوه‌ای کارآمد استفاده می‌کند. این روش از هویت زیر استفاده می‌کند:

![Fibonacci Matrix](/assets/FibonacciMatrix.png)

برای یافتن `F(n)`:

◻️​ماتریس تبدیل `‭[[1, 1], [1, 0]]‬` را به توان `n - 1` برسانید.


◻️عنصر اول ماتریس حاصل (F(n)) را برگردانید.


### ✅ چرا این روش کارآمد است:
◻️ از به توان رساندن دوگانه استفاده می‌کند.

◻️ پیچیدگی زمانی را به O(log n) کاهش می‌دهد.

◻️ از محاسبات تکراری جلوگیری می‌کند.

<br/>

## 📌 روش دوبل‌سازی سریع (Fast Doubling)
```javascript
function fibonacciFastDoubling(n) {
    // تابع کمکی بازگشتی که زوج [F(n), F(n+1)] را برمی‌گرداند
    function fastDbl(n) {
        // حالت پایه: F(0) = 0, F(1) = 1
        if (n === 0) return [0, 1];

        // محاسبه بازگشتی [F(k), F(k+1)] که k = floor(n / 2)
        const [a, b] = fastDbl(Math.floor(n / 2));

        // استفاده از هویت‌ها:
        // F(2k) = F(k) * [2*F(k+1) - F(k)]
        // F(2k + 1) = F(k+1)^2 + F(k)^2
        const c = a * (2 * b - a); // F(2k)
        const d = a * a + b * b;   // F(2k + 1)

        // اگر n زوج باشد: n = 2k
        if (n % 2 === 0) {
            return [c, d]; // [F(n), F(n+1)]
        } else {
            // اگر n فرد باشد: n = 2k + 1
            return [d, c + d]; // [F(n), F(n+1)]
        }
    }

    // بازگرداندن مقدار اولیه از زوج: F(n)
    return fastDbl(n)[0];
}
```
این روش از هویت‌های ریاضی فیبوناچی برای محاسبه سریع استفاده می‌کند:

![Fibonacci Fast Doubling : F(2k) = F(k) . (2F(k+1) - F(k))](/assets/FibonacciFD1.png)
![Fibonacci Fast Doubling : F(2k + 1) = F(k+1)^2 + F(k)^2](/assets/FibonacciFD2.png)


تابع به صورت بازگشتی `‭[F(k), F(k+1)]‬` را محاسبه کرده و بر اساس اینکه `n` زوج یا فرد است، مقادیر را ترکیب می‌کند.

### ✅ چرا این روش کارآمد است:

◻️ محاسبه F(n) را در O(log n) انجام می‌دهد.

◻️ در هر مرحله دو مقدار را برمی‌گرداند تا از محاسبه 
مجدد جلوگیری شود.

◻️ به طور کلی نسبت به روش ماتریس سریع‌تر است زیرا عملیات کمتری انجام می‌دهد.
