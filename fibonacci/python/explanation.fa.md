# 🧠 توضیحات کد فیبوناچی پایتون (فارسی)

## 📌 روش بازگشتی
```python
def fibonacci_recursive(n):
    # حالت پایه: اگر n کمتر یا برابر با ۰ باشد، ۰ را برگردانید
    if n <= 0:
        return 0
    # حالت پایه: اگر n برابر با ۱ باشد، ۱ را برگردانید
    elif n == 1:
        return 1
    # حالت بازگشتی: مجموع دو عدد فیبوناچی قبلی را برگردانید
    else:
        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)
```

این روش از یک رویکرد بازگشتی (Recursion) ساده استفاده می‌کند که در آن تابع خود را دوباره فراخوانی می‌کند تا دو عدد قبلی را محاسبه کند. این روش دارای پیچیدگی زمانی بالا به دلیل محاسبات تکراری بسیار زیاد است و زمان اجرای آن به صورت نمایی O(2ⁿ) می‌باشد.

<br/>

## 📌 روش غیر بازگشتی (حلقه‌ای)
```python
def fibonacci_iterative(n):
    # حالت پایه: اگر n کمتر یا برابر با ۰ باشد، ۰ را برگردانید
    if n <= 0:
        return 0
    # حالت پایه: اگر n برابر با ۱ باشد، ۱ را برگردانید
    elif n == 1:
        return 1
    
    # دو عدد فیبوناچی اول را مقداردهی اولیه کنید
    a, b = 0, 1
    # از ۲ تا n برای محاسبه اعداد فیبوناچی به صورت غیر بازگشتی حلقه بزنید
    for _ in range(2, n + 1):
        a, b = b, a + b  # a و b را به اعداد فیبوناچی بعدی به‌روزرسانی کنید
    return b  # عدد فیبوناچی nام را برگردانید
```

این روش از یک حلقه برای محاسبه اعداد فیبوناچی به صورت غیر بازگشتی استفاده می‌کند. این روش کارآمدتر از روش بازگشتی است زیرا از بار اضافی فراخوانی‌های چندگانه تابع جلوگیری می‌کند و دارای پیچیدگی زمانی خطی O(n) است.

<br />

## 📌 روش حافظه‌سازی (Memoization)
```python
def fibonacci_memoization(n, memo={}):
    # بررسی کنید که آیا نتیجه قبلاً محاسبه و در memo ذخیره شده است یا خیر
    if n in memo:
        return memo[n]
    # حالت پایه: اگر n کمتر یا برابر با ۰ باشد، ۰ را برگردانید
    if n <= 0:
        return 0
    # حالت پایه: اگر n برابر با ۱ باشد، ۱ را برگردانید
    elif n == 1:
        return 1
    
    # نتیجه را در memo ذخیره کنید تا از محاسبات تکراری جلوگیری شود
    memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)
    return memo[n]  # عدد فیبوناچی nام را برگردانید
```

این روش از ذخیره‌سازی مقادیر قبلی (Memoization) استفاده می‌کند تا از محاسبات تکراری جلوگیری کند.  با استفاده از  دیکشنری (memo)  نتایج
 را ذخیره کرده و در صورت نیاز دوباره استفاده می‌کند. این کار پیچیدگی زمانی را از O(2ⁿ) به O(n) کاهش می‌دهد و عملکرد برنامه را به میزان قابل توجهی بهبود می‌بخشد.


<br/>

## 📌 روش به توان رساندن ماتریس (Matrix Exponentiation)
```python
def fibonacci_matrix(n):
    # حالت پایه: فیبوناچی عدد 0 برابر با 0 است
    if n <= 0:
        return 0

    # تابع ضرب دو ماتریس ۲×۲
    def multiply(a, b):
        # مقداردهی اولیه ماتریس خروجی با صفر
        c = [[0, 0], [0, 0]]

        # انجام ضرب دستی برای ماتریس‌های ۲×۲
        for i in range(2):
            for j in range(2):
                # هر عنصر، حاصل ضرب سطر i از ماتریس a و ستون j از ماتریس b است
                c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j]

        # بازگرداندن ماتریس حاصل
        return c

    # تابع بازگشتی برای محاسبه ماتریس به توان n با استفاده از به توان رساندن دوگانه
    def power(mat, n):
        # حالت پایه: ماتریس به توان ۱ خودش است
        if n == 1:
            return mat

        # محاسبه به توان رساندن ماتریس برای n/2
        half = power(mat, n // 2)

        # مجذور کردن نتیجه
        sq = multiply(half, half)

        # اگر n فرد باشد، یک بار دیگر در ماتریس اصلی ضرب کن
        return multiply(sq, [[1, 1], [1, 0]]) if n % 2 else sq

    # شروع با ماتریس تبدیل [[1,1],[1,0]] و به توان رساندن آن به اندازه (n - 1)
    result = power([[1, 1], [1, 0]], n - 1)

    # عدد فیبوناچی، عنصر اول ماتریس حاصل است
    return result[0][0]
```
این روش از به توان رساندن ماتریس برای محاسبه عدد n-ام فیبوناچی به شیوه‌ای کارآمد استفاده می‌کند. این روش از هویت زیر استفاده می‌کند:

![Fibonacci Matrix](/assets/FibonacciMatrix.png)

برای یافتن `F(n)`:

◻️​ماتریس تبدیل `‭[[1, 1], [1, 0]]‬` را به توان `n - 1` برسانید.

◻️عنصر اول ماتریس حاصل (F(n)) را برگردانید.


### ✅ چرا این روش کارآمد است:
◻️ از به توان رساندن دوگانه استفاده می‌کند.

◻️ پیچیدگی زمانی را به O(log n) کاهش می‌دهد.

◻️ از محاسبات تکراری جلوگیری می‌کند.

<br/>

## 📌 روش دوبل‌سازی سریع (Fast Doubling)
```python
def fibonacci_fast_doubling(n):
    # تابع کمکی بازگشتی که زوج [F(n), F(n+1)] را برمی‌گرداند
    def fast_dbl(k):
        # حالت پایه: F(0) = 0, F(1) = 1
        if k == 0:
            return [0, 1]

        # محاسبه بازگشتی [F(k), F(k+1)] که k = floor(n / 2)
        a, b = fast_dbl(k // 2)

        # استفاده از هویت‌ها:
        # F(2k) = F(k) * [2*F(k+1) - F(k)]
        # F(2k + 1) = F(k+1)^2 + F(k)^2
        c = a * (2 * b - a)  # F(2k)
        d = a * a + b * b   # F(2k + 1)

        # اگر k زوج باشد: k = 2n
        if k % 2 == 0:
            return [c, d]  # [F(k), F(k+1)]
        else:
            # اگر k فرد باشد: k = 2n + 1
            return [d, c + d]  # [F(k), F(k+1)]

    # بازگرداندن مقدار اولیه از زوج: F(n)
    return fast_dbl(n)[0]
```
این روش از هویت‌های ریاضی فیبوناچی برای محاسبه سریع استفاده می‌کند:

![Fibonacci Fast Doubling : F(2k) = F(k) . (2F(k+1) - F(k))](/assets/FibonacciFD1.png)
![Fibonacci Fast Doubling : F(2k + 1) = F(k+1)^2 + F(k)^2](/assets/FibonacciFD2.png)


تابع به صورت بازگشتی `‭[F(k), F(k+1)]‬` را محاسبه کرده و بر اساس اینکه `n` زوج یا فرد است، مقادیر را ترکیب می‌کند.

### ✅ چرا این روش کارآمد است:

◻️ محاسبه F(n) را در O(log n) انجام می‌دهد.

◻️ در هر مرحله دو مقدار را برمی‌گرداند تا از محاسبه 
مجدد جلوگیری شود.

◻️ به طور کلی نسبت به روش ماتریس سریع‌تر است زیرا عملیات کمتری انجام می‌دهد.