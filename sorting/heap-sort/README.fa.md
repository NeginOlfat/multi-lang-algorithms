اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/heap-sort/README.md)

# 🟤 الگوریتم مرتب‌سازی هرمی (Heap Sort)

یک الگوریتم مرتب‌سازی مبتنی بر مقایسه که از ساختار دادهٔ **درخت دودویی هرم** (binary heap) برای یافتن و استخراج کارآمد بیشترین عنصر استفاده می‌کند.

مرتب‌سازی هرمی به این ترتیب کار می‌کند:

1▫️ ساخت یک **هرم بیشینه** (max-heap) از آرایه ورودی

2▫️ استخراج مکرر بیشترین عنصر (ریشه) و قرار دادن آن در انتهای آرایه

3▫️ کاهش اندازه هرم و بازسازی دوباره هرم

این الگوریتم **درجا انجام می‌شود**، **قابل پیش‌بینی است** و زمانی مناسب است که عملکرد در بدترین حالت مهم باشد.

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|-----------|--------------|
| بهترین    | O(n log n)   |
| متوسط     | O(n log n)   |
| بدترین   | O(n log n)   |

> ✅ برخلاف مرتب‌سازی سریع، مرتب‌سازی هرمی **همیشه** در زمان O(n log n) اجرا می‌شود — بدون شوک در بدترین حالت.

## 💾 پیچیدگی فضایی
◻️ **O(1)** — مرتب‌سازی درجا انجام می‌شود (تنها از حافظه اضافی ثابت استفاده می‌کند)

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ زمانی که **عملکرد در بدترین حالت** باید تضمین شود

◻️ در سیستم‌های بلادرنگ یا تعبیه‌شده (real-time یا embedded)

◻️ زمانی که به یک مرتب‌سازی درجا با زمان O(n log n) نیاز دارید

◻️ به عنوان پشتیبان برای مرتب‌سازی سریع (مثلاً در الگوریتم Introsort)

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```text
BEGIN HeapSort(array)
    n ← length(array)

    // ساخت هرم بیشینه از آرایه
    FOR i ← n/2 - 1 DOWNTO 0
        Heapify(array, n, i)
    END FOR

    // استخراج عناصر یکی یکی از هرم
    FOR i ← n - 1 DOWNTO 1
        SWAP array[0], array[i]  // ریشه را به انتها منتقل کن
        Heapify(array, i, 0)     // هرم را روی اندازه کاهش‌یافته بازسازی کن
    END FOR
END

BEGIN Heapify(array, heapSize, rootIndex)
    largest ← rootIndex
    left ← 2 * rootIndex + 1
    right ← 2 * rootIndex + 2

    IF left < heapSize AND array[left] > array[largest] THEN
        largest ← left
    END IF

    IF right < heapSize AND array[right] > array[largest] THEN
        largest ← right
    END IF

    IF largest ≠ rootIndex THEN
        SWAP array[rootIndex], array[largest]
        Heapify(array, heapSize, largest)
    END IF
END
```

> 💡 تابع `Heapify` تضمین می‌کند که زیردرخت ریشه‌دار در `rootIndex` خاصیت هرم بیشینه را داشته باشد. 


## 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[12, 11, 13, 5, 6, 7]‬`

از ایندکس‌گذاری مبتنی بر صفر استفاده می‌کنیم.

در یک هرم دودویی:

◻️ والد گره `i` = `(i - 1) / 2`

◻️ فرزند چپ گره `i` = `2 * i + 1`

◻️ فرزند راست گره `i` = `2 * i + 2`

### 🔁 مرحله ۱: ساخت هرم بیشینه
از آخرین گره برگ‌نما (non-leaf) شروع کرده و به سمت عقب (`heapify`) اعمال می‌کنیم.


◻️ اندازه آرایه = ۶ → آخرین ایندکس = ۵

◻️ آخرین گره برگ‌نما = `floor(6/2) - 1` = `2`

بنابراین `heapify` را از ایندکس `2` شروع می‌کنیم، سپس `1` و سپس `0`.

🔹 `i = 2` (مقدار = ۱۳)
```text
ایندکس: 
        ‭0   1   2   3   4   5‬
آرایه:
        ‭[12, 11, 13, 5, 6, 7]‬
                      ↑
           آیا گره ۲ فرزندی دارد؟ بررسی می‌کنیم:
           چپ  = 2*2+1 = 5 ← arr[5]=7
           راست = 2*2+2 = 6 ← خارج از محدوده

مقایسه: 13 > 7 ← از قبل بیشینه است ← جابه‌جایی نداریم
```
✅ تغییری نیست.

🔹 `i = 1` (مقدار = ۱۱)
```text
آرایه: 
        ‭[12, 11, 13, 5, 6, 7]‬
                      ↑
چپ  = 2*1+1 = 3 ← arr[3] = 5  
راست = 2*1+2 = 4 ← arr[4] = 6

بیشینه بین 11, 5, 6 ← 11 ← جابه‌جایی نداریم
```
✅ تغییری نیست.

🔹 `i = 0` (مقدار = ۱۲)
```text
آرایه:
        ‭[12, 11, 13, 5, 6, 7]‬
                           ↑
چپ  = 1 ← 11  
راست = 2 ← 13

13 > 12 ← جابه‌جایی 12 و 13

آرایه جدید: 
        ‭[13, 11, 12, 5, 6, 7]‬
```
اکنون بررسی می‌کنیم آیا زیردرخت با ریشه ایندکس ۲ (مقدار ۱۲) همچنان هرم است:

◻️ فرزند چپ = ۵ ← ایندکس ۵ ← مقدار ۷

◻️ ۱۲ > ۷ ← درست است

✅ هرم بیشینه ساخته شد!
```ascii
       13
      /  \
    11    12
   / \   /
  5   6 7
```

### 🔁 مرحله ۲: استخراج ماکسیمم و بازسازی هرم (یکی یکی)
حال که یک هرم بیشینه داریم، به طور مکرر:

1▫️ **جابه‌جایی** ریشه (بیشترین عنصر) با **آخرین عنصر هرم**

2▫️ **کاهش** اندازه هرم به اندازه ۱ (آخرین عنصر حالا در جای نهایی خود است)

3▫️ **بازسازی** خاصیت هرم با فراخوانی `heapify(0)`

بخش **مرتب‌شده** از راست به چپ رشد می‌کند، در حالی که **هرم** از چپ کوچک می‌شود.

بیایید هر مرحله را دقیق بررسی کنیم.

#### ​​⬅️ مرحله ۱: استخراج ۱۳ (بیشینه)
```text
هرم اولیه:
        ‭[13, 11, 12, 5, 6, 7]‬

جابه‌جایی ریشه (0) با آخرین عنصر (5): ← ‭[7, 11, 12, 5, 6, 13]‬

heapify(0): ریشه=7، چپ=11، راست=12 ← بیشینه=12 ← جابه‌جایی ← ‭[12, 11, 7, 5, 6, 13]‬
```
```
      12
     /  \
    11   7
   / \
  5   6
```
مرتب‌شده: `‭[ ..., 13]‬`

#### ​​⬅️ مرحله ۲: استخراج ۱۲ (بیشینه جدید)
```text
فعلی:
        ‭[12, 11, 7, 5, 6, 13]‬

جابه‌جایی ریشه (0) با آخرین عنصر (4): ← ‭[6, 11, 7, 5, 12, 13]‬

heapify(0): ریشه=6، چپ=11، راست=7 ← بیشینه=11 ← جابه‌جایی
← ‭[11, 6, 7, 5, 12, 13]‬
```
```
      11
     /  \
    6    7
   /
  5
```
مرتب‌شده: `‭[ ..., 12, 13]‬`

#### ​​⬅️ مرحله ۳: استخراج ۱۱
```text
فعلی:
          ‭[11, 6, 7, 5, 12, 13]‬

جابه‌جایی ریشه (0) با آخرین عنصر (3): ← ‭[5, 6, 7, 11, 12, 13]‬

heapify(0): ریشه=5، چپ=6، راست=7 ← بیشینه=7 ← جابه‌جایی
← ‭[7, 6, 5, 11, 12, 13]‬
```
```ascii
     7
    / \
   6   5
```
مرتب‌شده: `‭[ ..., 11, 12, 13]‬`

#### ​​⬅️ مرحله ۴: استخراج ۷
```text
فعلی: 
        ‭[7, 6, 5, 11, 12, 13]‬

جابه‌جایی ریشه (0) با آخرین عنصر (2): ← ‭[5, 6, 7, 11, 12, 13]‬

heapify(0): ریشه=5، چپ=6 ← 6 > 5 ← جابه‌جایی
← ‭[6, 5, 7, 11, 12, 13]‬
```
```
   6
  /
 5
```
مرتب‌شده: `‭[ ..., 7, 11, 12, 13]‬`

#### ​​⬅️ مرحله ۵: استخراج ۶
```text
فعلی:
        ‭[6, 5, 7, 11, 12, 13]‬

جابه‌جایی ریشه (0) با آخرین عنصر (1): ← ‭[5, 6, 7, 11, 12, 13]‬

اندازه هرم = 1 ← تمام شد!
```

**🧠 بینش کلیدی**

◻️ مرتب‌سازی هرمی از حافظه اضافی استفاده نمی‌کند — از انتهای آرایه برای ذخیره عناصر مرتب‌شده استفاده می‌کند.

◻️ هر فراخوانی `heapify` پس از استخراج، خاصیت هرم را بازسازی می‌کند.

◻️ بخش مرتب‌شده از **راست به چپ** رشد می‌کند.

> 🏁 مرتب‌سازی هرمی یک آرایه را با در نظر گرفتن آن به عنوان یک درخت دودویی و استخراج مکرر بیشترین عنصر، به یک لیست مرتب تبدیل می‌کند — همه درجا و در زمان تضمین‌شده O(n log n).

✅ آرایه نهایی: `‭[5, 6, 7, 11, 12, 13]‬`

## 💻 مراحل بعدی
زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/heap-sort/python/heap_sort.py) | [Java](/sorting/heap-sort/java/HeapSort.java) | [JavaScript](/sorting/heap-sort/javascript/heap-sort.js) | [C++](/sorting/heap-sort/c++/heap_sort.cpp) | [C#](/sorting/heap-sort/csharp/HeapSort.cs)
