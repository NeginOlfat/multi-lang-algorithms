اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/intro-sort/README.md)

# 🟣 الگوریتم مرتب‌سازی ترکیبی (Intro Sort)

یک الگوریتم مرتب‌سازی **ترکیبی**, **درجا** و **مقایسه‌ای** است که با **مرتب‌سازی سریع** شروع می‌شود، هنگامی که عمق بازگشتی بیش از حد زیاد شود به **مرتب‌سازی هرمی** تغییر می‌کند و از **مرتب‌سازی درجی** برای زیرآرایه‌های کوچک استفاده می‌کند.

این الگوریتم توسط **دیوید ماسر** در سال ۱۹۹۷ اختراع شد و **مرتب‌سازی ترکیبی** (Introspective Sort) طراحی شده تا هم **عملکرد میانگین سریع** داشته باشد و هم **guarantees بهینه در بدترین حالت** را فراهم کند.

> 💡 این الگوریتم **پیش‌فرض مرتب‌سازی** در موارد زیر است:
>
> ◻️ ✅ در `‭std::sort()‬`  —  **‭C++‬**  
>
> ◻️ ✅ کتابخانه‌های استاندارد **GCC** و **Clang**
>
> ◻️ ✅ در **.NET** برای برخی انواع آرایه

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|:-----------:|:--------------:|
| بهترین    | O(n log n)   |
| متوسط     | O(n log n)   |
| بدترین   | O(n log n)   |

> ⏱️ برخلاف مرتب‌سازی سریع، **بدترین حالت O(n²) ندارد** — تضمین O(n log n)

## 💾 پیچیدگی فضایی
◻️ **O(log n)** — به دلیل پشته بازگشتی (با حداکثر عمق محدود)

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ ✅ نیاز به مرتب‌سازی **سریع و قابل پیش‌بینی** داریم

◻️ ✅ می‌خواهیم عملکرد **O(n log n)** در بدترین حالت را تضمین کنیم

◻️ ✅ مرتب‌سازی **داده‌های بزرگ** با توزیع نامشخص

◻️ ✅ ساخت کتابخانه‌های با کارایی بالا

🚫 مناسب نیست برای:

◻️ مرتب‌سازی پایدار (مرتب‌سازی ترکیبی **پایدار نیست**)

◻️ محیط‌های با حافظه محدود

◻️ آموزش الگوریتم‌های پایه (خیلی پیچیده است)

## 🔄 نحوه کارکرد

مرتب‌سازی ترکیبی یک الگوریتم **ترکیبی سه مرحله‌ای** است که بر اساس ورودی و عمق بازگشتی تطبیق می‌یابد:

### 1. **مرحله ۱: مرتب‌سازی سریع (عملکرد میانگین سریع)**
◻️ با **مرتب‌سازی سریع** شروع می‌شود و از محور خوبی (مثلاً میانه سه عدد) استفاده می‌کند

◻️ روی داده‌های تصادفی به دلیل کارایی کش و سربار کم، سریع است

◻️ عمق بازگشتی را پیگیری می‌کند تا رفتار بدترین حالت شناسایی شود

### 2. **مرحله ۲: تغییر به مرتب‌سازی هرمی (جلوگیری از بدترین حالت)**
◻️ اگر عمق بازگشتی از `2 × log₂(n)` بیشتر شود، به **مرتب‌سازی هرمی** تغییر می‌کند

◻️ از بدترین حالت O(n²) مرتب‌سازی سریع روی داده‌های مرتب/تقریباً مرتب جلوگیری می‌کند

◻️ مرتب‌سازی هرمی از این نقطه به بعد O(n log n) را تضمین می‌کند

### 3. **مرحله ۳: مرتب‌سازی درجی (بهینه‌سازی زیرآرایه‌های کوچک)**
◻️ برای زیرآرایه‌هایی با اندازه ≤ ۱۶ (آستانه معمول)، از **مرتب‌سازی درجی** استفاده می‌شود

◻️ بسیار سریع روی آرایه‌های کوچک یا تقریباً مرتب

◻️ سربار فراخوانی‌های بازگشتی را کاهش می‌دهد

---

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[64, 34, 25, 12, 22, 11, 90]‬`

#### مرحله ۱: شروع با مرتب‌سازی سریع
◻️ انتخاب محور (مثلاً میانه سه عدد: ۳۴)

◻️ تقسیم: ‭`[25, 12, 22, 11]`, `34`, `[64, 90]`‬

◻️ بازگشت روی سمت چپ و راست

#### مرحله ۲: بررسی عمق بازگشتی
◻️ حداکثر عمق مجاز = `‭2 × log₂(7) ≈ 6‬`

◻️ اگر عمق در حین بازگشت از این مقدار بیشتر شود، به **مرتب‌سازی هرمی** تغییر کند

> (در این مثال کوچک، عمق باعث تغییر نمی‌شود)

#### مرحله ۳: بهینه‌سازی زیرآرایه‌های کوچک
◻️ وقتی اندازه زیرآرایه ≤ ۱۶ باشد، بازگشت متوقف می‌شود

◻️ **مرتب‌سازی درجی** روی قطعات کوچک اعمال می‌شود

#### نتیجه نهایی:
```
‭[11, 12, 22, 25, 34, 64, 90]‬
```

✅ مرتب شده با **تضمین O(n log n)**  
✅ بدون بدترین حالت O(n²) مثل مرتب‌سازی سریع

---

### 🧠 چرا از مرتب‌سازی ترکیبی استفاده کنیم؟

| استفاده در | پایدار؟ | بدترین حالت | سرعت میانگین | الگوریتم |
|-------:|-------:|----------:|---------:|--------:|
| C, Go | ❌ خیر | ❌ O(n²) | ⭐ سریع | مرتب‌سازی سریع |
| جاوا، پایتون | ✅ بله | ✅ O(n log n) | خوب | مرتب‌سازی ادغامی |
| — | ❌ خیر | ✅ O(n log n) | کند | مرتب‌سازی هرمی |
| **C++ std::sort** | ❌ خیر | ✅ O(n log n) | ⭐ سریع | **مرتب‌سازی ترکیبی** |

<br/>

◻️ ✅ **عملکرد میانگین سریع** (مثل مرتب‌سازی سریع)

◻️ ✅ **تضمین O(n log n)** (مثل مرتب‌سازی هرمی)

◻️ ✅ **بهینه‌سازی برای آرایه‌های کوچک** (مرتب‌سازی درجی)

◻️ ✅ **درجا** و سازگار با کش

---

### 📊 خلاصه مراحل

| هدف | مرحله |
|------:|--------:|
| تقسیم سریع در حالت میانگین | 1️⃣ مرتب‌سازی سریع |
| تشخیص بدترین حالت بازگشتی | 2️⃣ بررسی عمق |
| تضمین O(n log n) | 3️⃣ تغییر به مرتب‌سازی هرمی |
| بهینه‌سازی زیرآرایه‌های کوچک | 4️⃣ مرتب‌سازی درجی |
<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/intro-sort/python/intro_sort.py) | [Java](/sorting/intro-sort/java/IntroSort.java) | [JavaScript](/sorting/intro-sort/javascript/intro-sort.js) | [C++](/sorting/intro-sort/C++/intro_sort.cpp) | [C#](/sorting/intro-sort/csharp/IntroSort.cs)
