اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/pigeonhole-sort/README.md)

# 🕊️ الگوریتم مرتب‌سازی لانه کبوتری

یک الگوریتم مرتب‌سازی **غیرمقایسه‌ای** و **پایدار** است که با قرار دادن هر عنصر در "سکونت" خود (یک جایگاه متناظر با مقدار آن) کار می‌کند و سپس با پیمایش سکونت‌ها به ترتیب، آرایه مرتب را بازسازی می‌کند.

مرتب‌سازی لانه کبوتری بسیار شبیه به **مرتب‌سازی شمارشی** است، اما به جای ذخیره تعداد تکرارها، **عناصر واقعی** را در هر سکونت نگه می‌دارد. این امر آن را **پایدار** می‌کند و زمانی ایده‌آل است که نیاز به حفظ ترتیب اصلی عناصر برابر داشته باشد.

> 💡 فکر کنید به این صورت:  
> ◻️ **مرتب‌سازی شمارشی**: "از هر مقدار چند تا داریم؟"  
> ◻️ **مرتب‌سازی لانه کبوتری**: "هر عنصر باید به کجا برود؟"

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|:---------:|:------------:|
| بهترین    | O(n + k)     |
| متوسط     | O(n + k)     |
| بدترین   | O(n + k)     |

> ⏱️ که `n` = تعداد عناصر، `k` = محدوده مقادیر (ماکسیمم - مینیمم + 1)

## 💾 پیچیدگی فضایی
◻️ **O(n + k)** — برای ذخیره `k` سکونت و `n` عنصر

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ ✅ مرتب‌سازی **اعداد صحیح** یا داده‌های مشابه

◻️ ✅ **محدوده مقادیر (k)** **کوچک** و نزدیک به `n` باشد

◻️ ✅ نیاز به **عملکرد خطی** داریم

◻️ ✅ پایداری مطلوب است (مرتب‌سازی لانه کبوتری **پایدار** است)

🚫 مناسب نیست برای:

◻️ اعداد اعشاری

◻️ محدوده بسیار بزرگ از مقادیر (مثلاً `1` تا `10⁹`)

◻️ محیط‌های با حافظه محدود

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```ascii
BEGIN PigeonholeSort(array, min, max)
    n ← length(array)
    range ← max - min + 1
    pigeonholes ← array of 'range' empty lists

    // Step 1: Place each element in its pigeonhole
    FOR i ← 0 TO n - 1
        index ← array[i] - min
        APPEND array[i] TO pigeonholes[index]
    END FOR

    // Step 2: Reconstruct sorted array from left to right
    output ← empty list
    FOR i ← 0 TO range - 1
        FOR EACH element IN pigeonholes[i]
            APPEND element TO output
        END FOR
    END FOR

    RETURN output
END
```

> 🔍 توجه: ما `min` را کم می‌کنیم تا از آرایه‌های با اعداد منفی پشتیبانی کنیم.

---

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[8, 3, 5, 3, 1, 7]‬`

◻️ `n = 6` (تعداد عناصر)

◻️ `min = 1`, `max = 8` → `range = 8 - 1 + 1 = 8`

هدف ما مرتب‌سازی این آرایه به صورت **صعودی** با استفاده از **مرتب‌سازی لانه کبوتری** و با حفظ **پایداری** (عناصر برابر همان ترتیب نسبی خود را حفظ کنند).

#### ✅ مرحله ۱: ایجاد سکونت‌ها

ما **۸ سکونت خالی** ایجاد می‌کنیم (برای مقادیر ۱ تا ۸).  
هر سکونت در ایندکس `value - min` تمام تکرارهای آن مقدار را ذخیره می‌کند.

| مقدار | ایندکس (`value - 1`) | محتوای سکونت |
|:-----:| :-----------------: |:-------------------:|
| 1     | 0                   | [1]                 |
| 3     | 2                   | [3, 3]              |
| 5     | 4                   | [5]                 |
| 7     | 6                   | [7]                 |
| 8     | 7                   | [8]                 |

بقیه سکونت‌ها (ایندکس‌های ۱، ۳، ۵) خالی می‌مانند.

بنابراین آرایه `pigeonholes` به این صورت می‌شود:
```
ایندکس:
        ‭0     1     2     3     4     5     6     7‬
مقدار:
        ‭1     2     3     4     5     6     7     8‬
سکونت: 
        ‭[1]    []   [3,3]  []    [5]   []   [7]  [8]‬
```

> 💡 هر عنصر مستقیماً در سکونت صحیح خود قرار می‌گیرد — نیازی به مقایسه نیست.

---

#### ✅ مرحله ۲: بازسازی آرایه مرتب

ما سکونت‌ها را **از چپ به راست** پیمایش می‌کنیم و تمام عناصر را به ترتیب اضافه می‌کنیم:

```
سکونت 0: [1]        ← خروجی = [1]
سکونت 1: []         ← بدون تغییر
سکونت 2: [3, 3]     ← خروجی = ‭[1, 3, 3]‬
سکونت 3: []         ← بدون تغییر
سکونت 4: [5]        ← خروجی = ‭[1, 3, 3, 5]‬
سکونت 5: []         ← بدون تغییر
سکونت 6: [7]        ← خروجی = ‭[1, 3, 3, 5, 7]‬
سکونت 7: [8]        ← خروجی = ‭[1, 3, 3, 5, 7, 8]‬
```

#### ✅ نتیجه نهایی: `‭[1, 3, 3, 5, 7, 8]‬`

✅ مرتب شد!  
✅ پایدار: دو عدد `3` همان ترتیب نسبی خود از ورودی را حفظ کرده‌اند.

> 💡 **نکات نهایی**
>
> ◻️ مرتب‌سازی لانه کبوتری **درجا نیست** — به فضای اضافی O(n + k) نیاز دارد.
>
> ◻️ این روش **پایدار** است چون عناصر را به ترتیب ورودی اضافه می‌کنیم.
>
> ◻️ زمانی بهترین عملکرد را دارد که `k ≈ n` — اگر `k >> n`، از **مرتب‌سازی شمارشی** یا **رادیکس** استفاده کنید.
>
> ◻️ کاربرد واقعی: مرتب‌سازی نمرات، سن، یا شناسه‌ها با محدوده کوچک.

---

### 🧠 چرا از مرتب‌سازی لانه کبوتری به جای شمارشی استفاده کنیم؟

| ویژگی | مرتب‌سازی شمارشی | مرتب‌سازی لانه کبوتری |
|--------:|--------------:|----------------:|
| ذخیره می‌کند | فقط تعدادها | عناصر واقعی |
| پایدار؟ | فقط اگر درست انجام شود | ✅ بله (به طور طراحی) |
| فضا | O(k) | O(n + k) |
| مورد استفاده | فقط شمارش یا بازسازی | نیاز به عناصر اصلی به ترتیب |

<br/>

> 💡 **مرتب‌سازی لانه کبوتری در واقع همان مرتب‌سازی شمارشی است که به جای تعداد، عناصر را ذخیره می‌کند.**

---

### 📊 خلاصه مراحل

| مرحله | هدف |
|------:|--------:|
| 1️⃣ ایجاد سکونت‌ها | یکی برای هر مقدار ممکن |
| 2️⃣ توزیع | قرار دادن هر عنصر در سکونت خود |
| 3️⃣ بازسازی | پیمایش سکونت‌ها از چپ به راست، اضافه کردن همه عناصر |

<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/pigeonhole-sort/python/pigeonhole_sort.py) | [Java](/sorting/pigeonhole-sort/java/PigeonholeSort.java) | [JavaScript](/sorting/pigeonhole-sort/javascript/pigeonhole-sort.js) | [C++](/sorting/pigeonhole-sort/C++/pigeonhole_sort.cpp) | [C#](/sorting/pigeonhole-sort/csharp/PigeonholeSort.cs)