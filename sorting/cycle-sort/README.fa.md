اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/cycle-sort/README.md)

# 🟡 الگوریتم مرتب‌سازی چرخه‌ای

یک الگوریتم مرتب‌سازی **مقایسه‌ای** و **درجا** است که با قرار دادن هر عنصر به طور مستقیم در مکان صحیح خود، تعداد **نوشتن‌ها در حافظه** را به حداقل می‌رساند. این فرآیند از طریق یک سری **چرخه** (Cycle) انجام می‌شود.

برخلاف اکثر الگوریتم‌های مرتب‌سازی که بر کاهش مقایسه یا زمان متمرکز هستند، **مرتب‌سازی چرخه‌ای برای کاهش نوشتن‌ها بهینه شده است** — بنابراین برای محیط‌هایی که **عملیات نوشتن گران است** (مثل **حافظه فلش** یا **EEPROM**) ایده‌آل است.

> 💡 این الگوریتم **کمترین تعداد ممکن از نوشتن‌های حافظه** را برای مرتب‌سازی یک آرایه انجام می‌دهد.

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|-----------|--------------|
| بهترین    | O(n)         |
| متوسط     | O(n)         |
| بدترین   | O(n)         |

> ⏱️ همیشه کل آرایه را یک بار در هر چرخه اسکن می‌کند — خروج زودهنگام ممکن نیست.

## 💾 پیچیدگی فضایی
◻️ **O(1)** — مرتب‌سازی درجا انجام می‌شود و فقط چند متغیر اضافی نیاز دارد

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ ✅ وقتی **عملیات نوشتن در حافظه گران است** (مثلاً حافظه فلش)

◻️ ✅ داده به صورت تصادفی است اما مقادیر در یک محدوده شناخته شده قرار دارند

◻️ ✅ نیاز به کاهش سایش سخت‌افزار داریم (مثلاً سیستم‌های تعبیه‌شده)

◻️ ✅ آرایه شامل **عناصر مجزا** است (با تکرار کار می‌کند اما کمتر کارآمد است)

🚫 مناسب نیست برای:

◻️ مرتب‌سازی عمومی (کندتر از Quick/Heap/Merge)

◻️ زمانی که پایداری مطلوب باشد (مرتب‌سازی چرخه‌ای **پایدار نیست**)

◻️ محیط‌های با خواندن زیاد (تعداد خواندن‌ها بالا است)

## 🔄 نحوه کارکرد

هر عنصر یا قبلاً در مکان صحیح خود است، یا یک **چرخه** را شروع می‌کند که:

1▫️ عنصر فعلی به مکان صحیح خود منتقل می‌شود.

2▫️ عنصر جابه‌جا شده به مکان صحیح خود برده می‌شود.

3▫️ این فرآیند تا بازگشت به نقطه شروع ادامه می‌یابد.

هر چرخه فقط **یک نوشتن در حافظه** برای هر عنصر جابه‌جا شده نیاز دارد و **کمترین تعداد کل نوشتن‌ها** را در میان تمام الگوریتم‌های مرتب‌سازی دارد.

### 🧩 شبه‌کد

```
BEGIN CycleSort(array)
    n ← length(array)

    FOR cycleStart ← 0 TO n - 2
        item ← array[cycleStart]
        pos ← cycleStart

        // Find correct position for item
        FOR i ← cycleStart + 1 TO n - 1
            IF array[i] < item THEN
                pos ← pos + 1
            END IF
        END FOR

        // If item is already in correct position, skip
        IF pos == cycleStart THEN
            CONTINUE
        END IF

        // Skip duplicates
        WHILE item == array[pos] DO
            pos ← pos + 1
        END WHILE

        // Place item at correct position
        SWAP item, array[pos]

        // Rotate through the rest of the cycle
        WHILE pos ≠ cycleStart DO
            // Find next position
            pos ← cycleStart
            FOR i ← cycleStart + 1 TO n - 1
                IF array[i] < item THEN
                    pos ← pos + 1
                END IF
            END FOR

            // Skip duplicates
            WHILE item == array[pos] DO
                pos ← pos + 1
            END WHILE

            // Swap item into place
            SWAP item, array[pos]
        END WHILE
    END FOR
END
```

> 🔍 توجه: الگوریتم با **شمارش عناصر کوچک‌تر** از عنصر فعلی، مکان صحیح آن را پیدا می‌کند.

---

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[3, 2, 1, 4]‬`

هر موقعیت را بررسی کرده و چرخه‌ها را کامل می‌کنیم.

#### 🔁 چرخه ۱: شروع از ایندکس ۰ (`item = 3`)

◻️ تعداد عناصر کوچک‌تر از 3؟ ← `1, 2` ← شمارش = 2 ← مکان صحیح = `0 + 2 = 2`

◻️ جابه‌جایی `3` (ایندکس ۰) با `1` (ایندکس ۲) ← `‭[1, 2, 3, 4]‬`

◻️ اکنون `item = 1`، بازگشت به ایندکس ۰ ← آیا متعلق به اینجا است؟
 
◻️ تعداد عناصر کوچک‌تر از 1؟ ← ۰ ← مکان صحیح = ۰ ← تمام شد

✅ چرخه کامل شد.

#### 🔁 چرخه ۲: شروع از ایندکس ۱ (`item = 2`)

◻️ قبلاً در مکان صحیح است؟ بله ← رد شو

#### 🔁 چرخه ۳: شروع از ایندکس ۲ (`item = 3`)

◻️ قبلاً در مکان صحیح است؟ بله ← رد شو

#### 🔁 چرخه ۴: شروع از ایندکس ۳ (`item = 4`)

◻️ آخرین عنصر ← هیچ عملی

✅ نتیجه نهایی: `‭[1, 2, 3, 4]‬`

> 💡 فقط **۲ نوشتن** انجام شد (یکی برای هر عنصر جابه‌جا شده)، که **حداقل ممکن نظری** است.

---

### 🧠 چرا از مرتب‌سازی چرخه‌ای استفاده کنیم؟

| الگوریتم | نوشتن حداقل؟ |
|---------|-------------|
| مرتب‌سازی حبابی | ❌ خیر |
| مرتب‌سازی انتخابی | ❌ خیر |
| مرتب‌سازی درجی | ❌ خیر |
| **مرتب‌سازی چرخه‌ای** | ✅ **بله** |

◻️ تنها الگوریتم مرتب‌سازی است که **حداقل عملیات نوشتن** را تضمین می‌کند.

◻️ هر عنصر **حداکثر یک بار** به مکان نهایی خود نوشته می‌شود.

◻️ ایده‌آل برای **ذخیره‌سازی با محدودیت نوشتن**.

---

### 📊 خلاصه مراحل

| مرحله | هدف |
|------:|--------:|
| 1️⃣ شروع از `cycleStart` | شروع یک چرخه جدید |
| 2️⃣ شمارش عناصر کوچک‌تر | پیدا کردن مکان صحیح |
| 3️⃣ رد کردن تکراری‌ها | مدیریت مقادیر تکراری |
| 4️⃣ جابه‌جایی به مکان صحیح | شروع چرخه |
| 5️⃣ چرخش تا بازگشت به شروع | کامل کردن چرخه |

<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/cycle-sort/python/cycle_sort.py) | [Java](/sorting/cycle-sort/java/CycleSort.java) | [JavaScript](/sorting/cycle-sort/javascript/cycle-sort.js) | [C++](/sorting/cycle-sort/C++/cycle_sort.cpp) | [C#](/sorting/cycle-sort/csharp/CycleSort.cs)