اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/counting-sort/README.md)

# 🟢 الگوریتم مرتب‌سازی شمارشی

یک الگوریتم مرتب‌سازی **غیرمقایسه‌ای** است که با شمارش تعداد تکرار هر مقدار مجزا کار می‌کند و سپس آرایه مرتب‌شده را از روی این شمارش‌ها بازسازی می‌کند.

این روش **بسیار سریع** است وقتی محدوده مقادیر ورودی (`k`) نسبت به تعداد عناصر (`n`) کوچک باشد و به **پیچیدگی زمانی خطی O(n + k)** دست می‌یابد.

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|-----------|--------------|
| بهترین    | O(n + k)     |
| متوسط     | O(n + k)     |
| بدترین   | O(n + k)     |

> ⏱️ عملکرد به **محدوده مقادیر** بستگی دارد، نه فقط به تعداد عناصر.

## 💾 پیچیدگی فضایی
◻️ **O(k)** — که `k` محدوده مقادیر ورودی است (ماکسیمم - مینیمم + 1)

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ ✅ مرتب‌سازی **اعداد صحیح** یا داده‌های مشابه

◻️ ✅ محدوده کوچک مقادیر (مثلاً سن، نمرات، پیکسل‌ها)

◻️ ✅ نیاز به **عملکرد خطی** داریم

◻️ ✅ نیاز به پایداری داریم (مرتب‌سازی شمارشی **پایدار** است)

<br />

🚫 مناسب نیست برای:

◻️ اعداد اعشاری

◻️ محدوده بسیار بزرگ از مقادیر (مثلاً `1` تا `10⁹`)

◻️ محیط‌های محدود از نظر حافظه

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```
BEGIN CountingSort(array, min, max)
    n ← length(array)
    range ← max - min + 1
    count ← array of zeros of size 'range'
    output ← array of size n

    // مرحله ۱: شمارش تعداد هر عنصر
    FOR i ← 0 TO n - 1
        count[array[i] - min] ← count[array[i] - min] + 1
    END FOR

    // مرحله ۲: محاسبه شمارش تجمعی
    FOR i ← 1 TO range - 1
        count[i] ← count[i] + count[i - 1]
    END FOR

    // مرحله ۳: ساخت آرایه خروجی (از راست به چپ برای پایداری)
    FOR i ← n - 1 DOWN TO 0
        output[count[array[i] - min] - 1] ← array[i]
        count[array[i] - min] ← count[array[i] - min] - 1
    END FOR

    RETURN output
END
```

> 🔍 توجه: ما `min` را کم می‌کنیم تا از آرایه‌های با اعداد منفی پشتیبانی کنیم.

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[4, 2, 2, 8, 3, 3, 1]‬`

◻️ (تعداد عناصر) `n = 7` 

◻️ مقدار `min = 1`, `max = 8` ← پس محدوده `range = 8 - 1 + 1 = 8`

هدف ما مرتب‌سازی این آرایه به صورت **صعودی** با استفاده از **مرتب‌سازی شمارشی** و با حفظ **پایداری** (عناصر برابر همان ترتیب نسبی خود را حفظ کنند).

#### ✅ مرحله ۱: شمارش فراوانی

یک **آرایه شمارش** به اندازه `range = 8` (برای مقادیر ۱ تا ۸) ایجاد می‌کنیم.  
هر ایندکس نماینده یک مقدار (با افت فاصله `min`) است و تعداد تکرار آن را نگه می‌دارد.

> 🔢 ایندکس در `count` = `مقدار - min`

| مقدار | ایندکس (`value - 1`) | شمارش |
|:-----:| :-----------------: |:-----:|
| 1     | 0                   | 1
| 2     | 1                   | 2
| 3     | 2                   | 2
| 4     | 3                   | 1
| 8     | 7                   | 1

بنابراین آرایه `count` به این صورت می‌شود:
```
ایندکس: 
            ‭0   1   2   3   4   5   6   7‬

مقدار:
            ‭1   2   3   4   5   6   7   8‬

شمارش:
            ‭1   2   2   1   0   0   0   1‬
```
> 💡 آرایه `count` با فاصله `(value - min)` ایندکس‌گذاری می‌شود، نه خود مقدار. این امر پشتیبانی از اعداد منفی را ممکن می‌سازد.

این نشان می‌دهد:

◻️ عدد `1` یک بار آمده

◻️ عدد `2` دو بار آمده

◻️ عدد `3` دو بار آمده

◻️ عدد `4` یک بار آمده

◻️ عدد `8` یک بار آمده

---

#### ✅ مرحله ۲: محاسبه شمارش تجمعی

حالا آرایه `count` را به یک آرایه **تجمعی** تبدیل می‌کنیم که به ما می‌گوید:  
> «آخرین رخ‌داد مقدار `x` باید در ایندکس `count[x] - 1` قرار بگیرد.»

شمارش‌ها را جمع می‌کنیم:

```
شمارش اولیه:
                ‭[1, 2, 2, 1, 0, 0, 0, 1]‬
تجمعی:
  ایندکس ۰: 1
  ایندکس ۱: 1 + 2 = 3
  ایندکس ۲: 3 + 2 = 5
  ایندکس ۳: 5 + 1 = 6
  ایندکس ۴: 6 + 0 = 6
  ایندکس ۵: 6 + 0 = 6
  ایندکس ۶: 6 + 0 = 6
  ایندکس ۷: 6 + 1 = 7
```

بنابراین `count` تجمعی می‌شود:
```
ایندکس:
            ‭0   1   2   3   4   5   6   7‬

مقدار:
            ‭1   2   3   4   5   6   7   8‬

شمارش:
            ‭1   3   5   6   6   6   6   7‬
```

این یعنی:

◻️ همه مقادیر ≤ ۱ در ۱ موقعیت اول قرار می‌گیرند

◻️ همه مقادیر ≤ ۲ در ۳ موقعیت اول قرار می‌گیرند

◻️  و ...

◻️ همه مقادیر ≤ ۸ در ۷ موقعیت اول قرار می‌گیرند

پس **آخرین `3`** باید در **ایندکس ۴** قرار بگیرد (چون `count[2] = 5` ← موقعیت `5 - 1 = 4`)

---

#### ✅ مرحله ۳: ساخت آرایه خروجی (به صورت پایدار)

حالا روی آرایه اصلی از **راست به چپ** حرکت می‌کنیم تا **پایداری** حفظ شود.

هر عنصر را با استفاده از شمارش تجمعی در مکان نهایی صحیح قرار می‌دهیم.

`‭output = [0, 0, 0, 0, 0, 0, 0]‬` را مقداردهی اولیه می‌کنیم (اندازه ۷)

ورودی: `‭[4, 2, 2, 8, 3, 3, 1]‬` ← عناصر را به ترتیب: `‭1, 3, 3, 8, 2, 2, 4‬` پردازش می‌کنیم.

---

#### 🔁 پردازش هر عنصر:

1▫️ **عنصر = 1**

   ◻️ ایندکس در count: `1 - 1 = 0`
   
   ◻️ موقعیت = `count[0] - 1 = 1 - 1 = 0`
   
   ◻️ `1` در `output[0]` قرار می‌گیرد
   
   ◻️ و `count[0]` کاهش می‌یابد ← `count[0] = 0`
   
   ◻️ پس `output = [1, 0, 0, 0, 0, 0, 0]`

2▫️ **عنصر = 3** (دومین `3`)
   
   ◻️ ایندکس: `3 - 1 = 2`
   
   ◻️ موقعیت = `count[2] - 1 = 5 - 1 = 4`
   
   ◻️ `3` در `output[4]` قرار می‌گیرد
   
   ◻️ و `count[2]` کاهش می‌یابد ← `count[2] = 4`
   
   ◻️ پس `output = [1, 0, 0, 0, 3, 0, 0]`

3▫️ **عنصر = 3** (اولین `3`)
   
   ◻️ ایندکس: `3 - 1 = 2`
   
   ◻️ موقعیت = `count[2] - 1 = 4 - 1 = 3`
   
   ◻️ `3` در `output[3]` قرار می‌گیرد
   
   ◻️ و `count[2]` کاهش می‌یابد ← `count[2] = 3`
   
   ◻️ پس `output = [1, 0, 0, 3, 3, 0, 0]`

4▫️ **عنصر = 8**
   
   ◻️ ایندکس: `8 - 1 = 7`
   
   ◻️ موقعیت = `count[7] - 1 = 7 - 1 = 6`
   
   ◻️ `8` در `output[6]` قرار می‌گیرد
   
   ◻️ و `count[7]` کاهش می‌یابد ← `count[7] = 6`
   
   ◻️ پس `output = [1, 0, 0, 3, 3, 0, 8]`

5▫️ **عنصر = 2** (دومین `2`)
   
   ◻️ ایندکس: `2 - 1 = 1`
   
   ◻️ موقعیت = `count[1] - 1 = 3 - 1 = 2`
   
   ◻️ `2` در `output[2]` قرار می‌گیرد
   
   ◻️ و `count[1]` کاهش می‌یابد ← `count[1] = 2`
   
   ◻️ پس `output = [1, 0, 2, 3, 3, 0, 8]`

6▫️ **عنصر = 2** (اولین `2`)

   ◻️ ایندکس: `2 - 1 = 1`
   
   ◻️ موقعیت = `count[1] - 1 = 2 - 1 = 1`
   
   ◻️ `2` در `output[1]` قرار می‌گیرد
   
   ◻️ و `count[1]` کاهش می‌یابد ← `count[1] = 1`
   
   ◻️ پس `output = [1, 2, 2, 3, 3, 0, 8]`

7▫️ **عنصر = 4**

   ◻️ ایندکس: `4 - 1 = 3`
   
   ◻️ موقعیت = `count[3] - 1 = 6 - 1 = 5`
   
   ◻️ `4` در `output[5]` قرار می‌گیرد
   
   ◻️ و `count[3]` کاهش می‌یابد ← `count[3] = 5`
   
   ◻️ پس `output = [1, 2, 2, 3, 3, 4, 8]`

---

#### 🔄 جدول تکامل خروجی

| مرحله | عنصر | موقعیت خروجی | آرایه خروجی |
|------|--------|------------------|--------------|
| 1 | 1 | 0 | `‭[1, _, _, _, _, _, _]‬` |
| 2 | 3 | 4 | `‭[1, _, _, _, 3, _, _]‬` |
| 3 | 3 | 3 | `‭[1, _, _, 3, 3, _, _]‬` |
| 4 | 8 | 6 | `‭[1, _, _, 3, 3, _, 8]‬` |
| 5 | 2 | 2 | `‭[1, _, 2, 3, 3, _, 8]‬` |
| 6 | 2 | 1 | `‭[1, 2, 2, 3, 3, _, 8]‬` |
| 7 | 4 | 5 | `‭[1, 2, 2, 3, 3, 4, 8]‬` |

---


✅ نتیجه نهایی:`‭[1, 2, 2, 3, 3, 4, 8]‬`

✅ مرتب شد!  
✅ پایدار: دو عدد `2` و دو عدد `3` همان ترتیب نسبی خود را از ورودی حفظ کرده‌اند.

> 💡 **نکات نهایی**
>
>◻ مرتب‌سازی شمارشی **درجا نیست** — به فضای اضافی O(k) نیاز دارد.
>
>◻  اغلب به عنوان زیرالگوریتم در **مرتب‌سازی رادیکس** استفاده می‌شود.
>
>◻  کاربردهای واقعی: مرتب‌سازی سن، نمرات، پیکسل‌ها یا شناسه‌ها.

---

### 🧠 چرا از راست به چپ حرکت می‌کنیم؟

◻️ برای حفظ **پایداری**

◻️ شمارش تجمعی **آخرین موقعیت ممکن** برای یک مقدار را نشان می‌دهد

◻️ با حرکت **راست به چپ**، آخرین رخ‌داد یک مقدار اول قرار می‌گیرد و سپس رخ‌دادهای قبلی قبل از آن قرار می‌گیرند

◻️ این امر تضمین می‌کند که عناصر برابر ترتیب اصلی خود را حفظ کنند

---

### 📊 خلاصه مراحل

| مرحله | هدف |
|:------:|:--------:|
| 1️⃣ شمارش | تعداد تکرار هر مقدار را بشماریم |
| 2️⃣ تجمعی | موقعیت نهایی مقادیر را تعیین کنیم |
| 3️⃣ ساخت خروجی (راست به چپ) | عناصر را به صورت پایدار در جای صحیح قرار دهیم |

<br />

## 💻​ مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/counting-sort/python/counting_sort.py) | [Java](/sorting/counting-sort/java/CountingSort.java) | [JavaScript](/sorting/counting-sort/javascript/counting-sort.js) | [C++](/sorting/counting-sort/C++/counting_sort.cpp) | [C#](/sorting/counting-sort/csharp/CountingSort.cs)