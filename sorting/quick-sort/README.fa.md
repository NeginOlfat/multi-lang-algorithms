این مطلب را به زبان‌های دیگر بخوانید: [English](/sorting/quick-sort/README.md)
# 🔴 الگوریتم مرتب‌سازی سریع

یک الگوریتم مرتب‌سازی بسیار کارآمد مبتنی بر روش **تقسیم و حل** که با انتخاب یک عنصر به عنوان "محور" (pivot) کار می‌کند و آرایه را حول آن تقسیم می‌کند.

عناصر کوچکتر به سمت چپ و بزرگترها به سمت راست منتقل می‌شوند. این فرآیند به صورت بازگشتی روی هر دو طرف ادامه می‌یابد.

مرتب‌سازی سریع به دلیل **سرعت بالای متوسط**، الگوریتم پیش‌فرض مرتب‌سازی در بسیاری از کتابخانه‌های استاندارد است.

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|-----------|--------------|
| بهترین    | O(n log n)   |
| متوسط     | O(n log n)   |
| بدترین   | O(n²)        |

> ⚠️ بدترین حالت زمانی رخ می‌دهد که محور همیشه کوچکترین/بزرگترین عنصر باشد (مثلاً در آرایه‌های مرتب‌شده). 

> ✅ اما با انتخاب تصادفی محور یا روش "میانه سه‌تایی"، این حالت در عمل جلوگیری می‌شود.

## 💾 پیچیدگی فضایی
◻️ **O(log n)** — به دلیل عمق پشته بازگشتی (تقسیم درجا انجام می‌شود)

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ مرتب‌سازی عمومی

◻️ زمانی که عملکرد مهم است

◻️ داده‌ها از قبل مرتب یا تقریباً مرتب نیستند (بدون تصادفی‌سازی)

◻️ زمانی که نیاز به مرتب‌سازی درجا با عملکرد متوسط خوب دارید

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```text
BEGIN QuickSort(array, low, high)
    IF low < high THEN
        // تقسیم آرایه و یافتن ایندکس محور
        pivotIndex ← Partition(array, low, high)

        // مرتب‌سازی بازگشتی قسمت‌های قبل و بعد از محور
        QuickSort(array, low, pivotIndex - 1)
        QuickSort(array, pivotIndex + 1, high)
    END IF
END

BEGIN Partition(array, low, high)
    pivot ← array[high]  // انتخاب آخرین عنصر به عنوان محور
    i ← low - 1          // ایندکس عنصر کوچکتر

    FOR j ← low TO high - 1
        IF array[j] ≤ pivot THEN
            i ← i + 1
            SWAP array[i], array[j]
        END IF
    END FOR

    SWAP array[i + 1], array[high]
    RETURN i + 1
END
```
> 💡 این روش از شیوه تقسیم لو موتو (Lomuto) استفاده می‌کند — ساده و مناسب برای مبتدیان. 

### 🔄 مثال گام به گام
آرایه زیر را مرتب می‌کنیم: `‭[10, 80, 30, 90, 40, 50, 70]‬`

از آخرین عنصر به عنوان محور استفاده می‌کنیم.

#### 🔁 فراخوانی اولیه: `QuickSort(arr, 0, 6)`

##### مرحله ۱: محور = 70 (ایندکس ۶)
تقسیم حول `۷۰`:

◻️ تمام عناصر ≤ ۷۰ به سمت چپ منتقل می‌شوند

◻️ آرایه پس از تقسیم: `‭[10, 30, 40, 50, 70, 90, 80]‬`

◻️  محور اکنون در ایندکس ۴ قرار دارد → `pivotIndex = 4`

##### مرحله ۲: فراخوانی بازگشتی:

◻️ چپ: `QuickSort(arr, 0, 3)` → `‭[10, 30, 40, 50]‬`

◻️ راست: `QuickSort(arr, 5, 6)` → `‭[90, 80]‬`

این فرآیند تا زمانی ادامه می‌یابد که آرایه کاملاً مرتب شود.

✅ نتیجه نهایی: `‭[10, 30, 40, 50, 70, 80, 90]‬`

> 💡 مرتب‌سازی سریع بیشتر کار را قبل از بازگشت انجام می‌دهد (برخلاف مرتب‌سازی ادغامی). 

<br />

## ➡️ مراحل بعدی
زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/quick-sort/python/quick_sort.py) | [Java](/sorting/quick-sort/java/QuickSort.java) | [JavaScript](/sorting/quick-sort/javascript/quick-sort.js) | [C++](/sorting/quick-sort/c++/quick_sort.cpp) | [C#](/sorting/quick-sort/csharp/QuickSort.cs)