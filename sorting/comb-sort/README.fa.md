اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/comb-sort/README.md)

# 🔵 الگوریتم مرتب‌سازی شانه‌ای

نسخه‌ای **بهبودیافته از مرتب‌سازی حبابی** است که "لاک‌پشت‌ها" — مقادیر کوچک در انتهای لیست — را با استفاده از **فاصله‌ای بزرگ‌تر از ۱** در مقایسه‌ها حذف می‌کند. این فاصله در طول زمان کاهش می‌یابد تا زمانی که به ۱ برسد، که در آن نقطه الگوریتم مانند مرتب‌سازی حبابی عمل می‌کند.

مرتب‌سازی شانه‌ای پیاده‌سازی ساده‌ای دارد و در عمل عملکرد بسیار بهتری نسبت به مرتب‌سازی حبابی دارد، به ویژه در داده‌های تقریباً مرتب یا معکوس.

> 💡 آن را مانند **مرتب‌سازی حبابی با یک شانه** تصور کنید — به جای مقایسه عناصر مجاور، عناصری که فاصله دارند را مقایسه می‌کند و اجازه می‌دهد مقادیر کوچک دوردست به سرعت به جلو "بپرند".

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|:---------:|:-------------:|
| بهترین    | O(n log n)   |
| متوسط     | O(n log n)   |
| بدترین   | O(n²)        |

> ⏱️ عملکرد به **ضریب کاهش** (معمولاً ۱.۳) بستگی دارد

## 💾 پیچیدگی فضایی
◻️​ **O(1)** — مرتب‌سازی درجا انجام می‌شود و فقط چند متغیر اضافی نیاز دارد

## ✅ چه زمانی از آن استفاده کنیم؟
◻️​ ✅ نیاز به یک الگوریتم مرتب‌سازی **ساده و درجا** داریم

◻️​ ✅ می‌خواهیم چیزی **سریع‌تر از مرتب‌سازی حبابی**   اما ساده‌تر از مرتب‌سازی سریع داشته باشیم

◻️​ ✅ آموزش مفاهیم مرتب‌سازی (عالی برای نشان دادن بهینه‌سازی)

◻️​ ✅ داده "لاک‌پشت" دارد (مقادیر کوچک در انتهای لیست)

🚫 مناسب نیست برای:

◻️​ داده‌های بسیار بزرگ

◻️​ زمانی که عملکرد تضمینی O(n log n) مطلوب باشد

◻️​ مرتب‌سازی پایدار (مرتب‌سازی شانه‌ای **پایدار نیست**)

## 🔄 نحوه کارکرد

به جای مقایسه همیشگی عناصر مجاور (فاصله = ۱)، مرتب‌سازی شانه‌ای با یک فاصله بزرگ شروع می‌کند و آن را در طول زمان کاهش می‌دهد.

**فاصله** با یک **ضریب کاهش** (معمولاً **۱.۳**) کاهش می‌یابد تا زمانی که به ۱ برسد.

این امر به عناصر دوردست اجازه می‌دهد به سرعت به سمت مکان صحیح خود حرکت کنند.

### 🧩 شبه‌کد

```
BEGIN CombSort(array)
    n ← length(array)
    gap ← n
    swapped ← TRUE

    WHILE gap > 1 OR swapped = TRUE
        // Shrink gap by shrink factor (1.3)
        gap ← FLOOR(gap / 1.3)
        IF gap < 1 THEN
            gap ← 1
        END IF

        swapped ← FALSE

        // Compare elements with current gap
        FOR i ← 0 TO n - 1 - gap
            IF array[i] > array[i + gap] THEN
                SWAP array[i], array[i + gap]
                swapped ← TRUE
            END IF
        END FOR
    END WHILE
END
```

> 🔍 توجه: ضریب کاهش بهینه **۱.۳** است که از طریق آزمایش تجربی کشف شده است.

---

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[64, 34, 25, 12, 22, 11, 90]‬`

از **ضریب کاهش = ۱.۳** استفاده می‌کنیم

#### مرحله ۱: فاصله = ۵ (floor(7 / 1.3) ≈ 5)

مقایسه عناصر با فاصله ۵:

◻️​ (0,5): 64 در مقابل 11 ← جابه‌جایی ← `‭[11, 34, 25, 12, 22, 64, 90]‬`

◻️​ (1,6): 34 در مقابل 90 ← بدون جابه‌جایی

#### مرحله ۲: فاصله = ۳ (floor(5 / 1.3) ≈ 3)

مقایسه عناصر با فاصله ۳:

◻️ (0,3): 11 در مقابل 12 ← بدون جابه‌جایی

◻️ (1,4): 34 در مقابل 22 ← جابه‌جایی ← `‭[11, 22, 25, 12, 34, 64, 90]‬`

◻️ (2,5): 25 در مقابل 64 ← بدون جابه‌جایی

◻️ (3,6): 12 در مقابل 90 ← بدون جابه‌جایی

#### مرحله ۳: فاصله = ۲ (floor(3 / 1.3) ≈ 2)

مقایسه عناصر با فاصله ۲:

◻️ (0,2): 11 در مقابل 25 ← بدون جابه‌جایی

◻️ (1,3): 22 در مقابل 12 ← جابه‌جایی ← `‭[11, 12, 25, 22, 34, 64, 90]‬`

◻️ (2,4): 25 در مقابل 34 ← بدون جابه‌جایی

◻️ (3,5): 22 در مقابل 64 ← بدون جابه‌جایی

◻️ (4,6): 34 در مقابل 90 ← بدون جابه‌جایی

#### مرحله ۴: فاصله = ۱ (floor(2 / 1.3) ≈ 1)

حالا مانند مرتب‌سازی حبابی عمل می‌کند:

◻️ یک عبور کامل با جابه‌جایی ← `‭[11, 12, 22, 25, 34, 64, 90]‬`

✅ نتیجه نهایی: `‭[11, 12, 22, 25, 34, 64, 90]‬`

> 💡 فاصله اولیه بزرگ به `11` کمک کرد تا از انتها به جلو به سرعت حرکت کند — مشکل "لاک‌پشت" را حل کرد.

---

### 🧠 چرا از مرتب‌سازی شانه‌ای استفاده کنیم؟

| الگوریتم | لاک‌پشت‌ها؟ | سرعت | سادگی |
|--------:|--------:|------:|----------:|
| مرتب‌سازی حبابی | ❌ بله (کند) | O(n²) | ✅ بسیار ساده |
| **مرتب‌سازی شانه‌ای** | ✅ نه | O(n log n) متوسط | ✅ ساده |
| مرتب‌سازی سریع | ✅ نه | O(n log n) متوسط | ❌ پیچیده |

<br/>

◻️ **حذف لاک‌پشت‌ها**: مقادیر کوچک در انتها به سرعت به جلو حرکت می‌کنند.

◻️ **ساده برای پیاده‌سازی**: فقط مرتب‌سازی حبابی را اصلاح کنید.

◻️ **عملکرد متوسط بهتر**: به دلیل فاصله‌های بزرگ اولیه.

---

### 📊 خلاصه مراحل

| هدف | مرحله |
|------:|------:|
| اجازه حرکت عناصر دوردست | 1️⃣ شروع با فاصله بزرگ |
| به تدریج ترتیب را بهبود بخشید | 2️⃣ کاهش فاصله با ضریب ۱.۳ |
| تشخیص زمانی که آرایه مرتب شده است | 3️⃣ استفاده از پرچم swapped |
| تمیزکاری مانند مرتب‌سازی حبابی | 4️⃣ عبور نهایی با فاصله=۱ |
<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/comb-sort/python/comb_sort.py) | [Java](/sorting/comb-sort/java/CombSort.java) | [JavaScript](/sorting/comb-sort/javascript/comb-sort.js) | [C++](/sorting/comb-sort/C++/comb_sort.cpp) | [C#](/sorting/comb-sort/csharp/CombSort.cs)