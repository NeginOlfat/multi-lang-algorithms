اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/bucket-sort/README.md)

# 🟣 الگوریتم مرتب‌سازی سطلی

یک الگوریتم مرتب‌سازی **مبتنی بر توزیع** است که با تقسیم ورودی به چندین "سطل" کار می‌کند، هر سطل را به صورت جداگانه (معمولاً با الگوریتمی مانند مرتب‌سازی درجی) مرتب می‌کند و سپس سطل‌ها را ادغام می‌کند تا آرایه نهایی مرتب شده تولید شود.

مرتب‌سازی سطلی عملکرد بسیار خوبی دارد وقتی داده‌ها **به صورت یکنواخت در یک محدوده توزیع شده باشند** و می‌تواند به **پیچیدگی زمانی متوسط O(n + k)** دست یابد که در آن `k` تعداد سطل‌ها است.

## 📈 پیچیدگی زمانی

| حالت       | زمان               |
|-----------|--------------------|
| بهترین    | O(n + k)           |
| متوسط     | O(n + k)           |
| بدترین   | O(n²)              |

> ⏱️ بهترین زمان زمانی رخ می‌دهد که داده‌ها **به صورت یکنواخت توزیع شده باشند**  
> ⏱️ بدترین حالت زمانی رخ می‌دهد که تمام عناصر در یک سطل قرار بگیرند (مثلاً با استفاده از مرتب‌سازی درجی برای هر سطل)

## 💾 پیچیدگی فضایی
​◻️  **O(n + k)** — برای ذخیره `k` سطل و `n` عنصر

## ✅ چه زمانی از آن استفاده کنیم؟
​◻️ ✅ ورودی **به صورت یکنواخت توزیع شده** باشد (مثلاً اعداد اعشاری تصادفی در بازه [0,1))

​◻️ ✅ نیاز به **عملکرد خطی متوسط** داریم

​◻️ ✅ مرتب‌سازی **اعداد اعشاری** یا **مقادیر با محدوده ثابت**

​◻️ ✅ بتوانیم مینیمم و ماکسیمم ورودی را تخمین بزنیم

🚫 مناسب نیست برای:

​◻️ داده‌های بسیار نامتعادل یا خوشه‌ای

​◻️ محدوده نامشخص یا نامحدود

​◻️ محیط‌های با حافظه محدود (به دلیل فضای اضافی)

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```
BEGIN BucketSort(array, numBuckets)
    IF array is empty OR has one element: RETURN array

    min ← findMin(array)
    max ← findMax(array)
    range ← max - min

    // Create k empty buckets
    buckets ← array of k empty lists

    // Distribute elements into buckets
    FOR each element IN array
        bucketIndex ← floor((element - min) / range * (numBuckets - 1))
        INSERT element INTO buckets[bucketIndex]
    END FOR

    // Sort each bucket (using Insertion Sort or another algorithm)
    FOR each bucket IN buckets
        INSERTION_SORT(bucket)
    END FOR

    // Concatenate all buckets into output
    output ← empty list
    FOR each bucket IN buckets
        APPEND all elements of bucket TO output
    END FOR

    RETURN output
END
```

> 🔍 توجه: برای اعداد صحیح، می‌توانید از فرمول زیر استفاده کنید:  
> `bucketIndex = (element - min) * numBuckets / (max - min + 1)`

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[0.42, 0.32, 0.33, 0.52, 0.37, 0.47, 0.51]‬`  
از **5 سطل** برای محدوده [0, 1) استفاده می‌کنیم.

#### مرحله ۱: پیدا کردن مینیمم و ماکسیمم
- min = 0.32, max = 0.52 → range = 0.20

#### مرحله ۲: توزیع در سطل‌ها

| سطل | محدوده | فرمول ایندکس | عناصر |
|-----|--------|--------------|-------|
| 0 | [0.32–0.36) | `(x-0.32)/0.20 * 4` → [0, 1) | 0.33 |
| 1 | [0.36–0.40) | → [1, 2) | 0.37 |
| 2 | [0.40–0.44) | → [2, 3) | 0.42 |
| 3 | [0.44–0.48) | → [3, 4) | 0.47 |
| 4 | [0.48–0.52] | → [4, 5) → به 4 محدود می‌شود | 0.52, 0.51 |

> توجه: 0.32 ← سطل 0, 0.52 ← سطل 4 (مرز بالایی شامل است)

#### مرحله ۳: مرتب‌سازی هر سطل
​◻️ سطل 4: `[0.52, 0.51]` ← مرتب شده ← `[0.51, 0.52]`

بقیه سطل‌ها فقط یک عنصر دارند ← از قبل مرتب هستند.

#### مرحله ۴: ادغام سطل‌ها
```
سطل 0: [0.33]
سطل 1: [0.37]
سطل 2: [0.42]
سطل 3: [0.47]
سطل 4: [0.51, 0.52]
```

✅ نتیجه نهایی: `‭[0.33, 0.37, 0.42, 0.47, 0.51, 0.52]‬`  
(اما 0.32 را فراموش کردیم! در ادامه اصلاح می‌کنیم!)

> 💡 صبر کنید — ما **0.32** را فراموش کردیم!  
> اصلاح:  
> `bucketIndex = floor((0.32 - 0.32)/0.20 * 4) = 0` ← پس 0.32 به **سطل 0** می‌رود  
> سطل 0 می‌شود: `[0.33, 0.32]` ← مرتب شده ← `[0.32, 0.33]`

✅ **نتیجه نهایی اصلاح‌شده:** `‭[0.32, 0.33, 0.37, 0.42, 0.47, 0.51, 0.52]‬`

---

### 🧠 چرا مرتب‌سازی سطلی کار می‌کند؟

◻️ داده‌ها را به زیرمسائل کوچک‌تر تقسیم می‌کند (مثل مرتب‌سازی ادغامی)

◻️ زمانی بهترین عملکرد را دارد که عناصر **به طور یکنواخت پخش شده باشند**

◻️ از مرتب‌سازی ثانویه (مثل درجی) روی سطل‌های کوچک استفاده می‌کند — که کارآمد است

◻️ با توزیع اولیه، از محدودیت‌های مقایسه‌ای اجتناب می‌کند

---

### 📊 خلاصه مراحل

| مرحله | هدف |
|------:|--------:|
| 1️⃣ پیدا کردن مینیمم و ماکسیمم | تعیین محدوده برای نگاشت سطل |
| 2️⃣ ایجاد سطل‌ها | تخصیص k لیست خالی |
| 3️⃣ توزیع | قرار دادن هر عنصر در سطل صحیح |
| 4️⃣ مرتب‌سازی سطل‌ها | استفاده از مرتب‌سازی درجی یا الگوریتم دیگر |
| 5️⃣ ادغام | ترکیب تمام سطل‌ها به ترتیب |

<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/bucket-sort/python/bucket_sort.py) | [Java](/sorting/bucket-sort/java/BucketSort.java) | [JavaScript](/sorting/bucket-sort/javascript/bucket-sort.js) | [C++](/sorting/bucket-sort/C++/bucket_sort.cpp) | [C#](/sorting/bucket-sort/csharp/BucketSort.cs)