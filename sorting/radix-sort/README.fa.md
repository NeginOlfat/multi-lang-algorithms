اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/radix-sort/README.md)

# 🔴 الگوریتم مرتب‌سازی رادیکس

یک الگوریتم مرتب‌سازی **غیرمقایسه‌ای** است که اعداد صحیح (یا رشته‌های با طول ثابت) را با پردازش رقم به رقم، از **کم‌ارزش‌ترین رقم (LSD)** به **پرارزش‌ترین رقم (MSD)**، مرتب می‌کند. این روش از یک زیرالگوریتم **پایدار** — معمولاً **مرتب‌سازی شمارشی** — استفاده می‌کند.

الگوریتم رادیکس از این ایده استفاده می‌کند که اعداد را می‌توان رقم به رقم مرتب کرد و در صورت کوچک بودن تعداد رقم‌ها (`d`)، به **پیچیدگی زمانی خطی O(d × n)** دست یافت.

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|:---------:|:------------:|
| بهترین    | O(d × n)     |
| متوسط     | O(d × n)     |
| بدترین   | O(d × n)     |

> ⏱️ که `d` = تعداد رقم‌ها، `n` = تعداد عناصر  
> ⏱️ عملکرد بهتر از الگوریتم‌های مقایسه‌ای (Ω(n log n)) — اما فقط برای انواع خاص داده.

## 💾 پیچیدگی فضایی
◻️ **O(n + k)** — `k` مبنای اعداد است (مثلاً ۱۰ برای ارقام ده‌دهی)

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ ✅ مرتب‌سازی **اعداد صحیح**, **شماره تلفن**, **شناسه‌ها**, یا **رشته‌های با طول ثابت**

◻️ ✅ نیاز به **عملکرد خطی** داریم

◻️ ✅ داده دارای **تعداد رقم ثابت** است یا قابل تکمیل با صفر

◻️ ✅ پایداری مطلوب است (در صورت استفاده از زیرالگوریتم پایدار)

🚫 مناسب نیست برای:

◻️ اعداد اعشاری (بدون رمزگذاری خاص)

◻️ رشته‌های با طول متغیر (بدون تکمیل)

◻️ اشیای دلخواه

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```
BEGIN RadixSort(array)
    if array is empty or has one element: RETURN array

    max ← find maximum element in array
    d ← number of digits in max

    FOR i ← 0 TO d - 1
        // Sort by i-th digit using a stable sort (e.g., Counting Sort)
        array ← CountingSortByDigit(array, i)
    END FOR

    RETURN array
END

// Helper: Extract i-th digit (from right, 0-indexed)
FUNCTION getDigit(num, i)
    RETURN (num / (10^i)) % 10
END
```

> 🔍 توجه: از **مرتب‌سازی شمارشی** به عنوان زیرالگوریتم استفاده می‌شود — تضمین می‌کند که مرتب‌سازی پایدار باشد.

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[170, 45, 75, 90, 2, 802, 24, 66]‬`

رقم به رقم از **راست به چپ** (Radix Sort با LSD) پیش می‌رویم.

#### مرحله ۱: مرتب‌سازی بر اساس رقم یکان (10⁰)

| عدد  | رقم یکان |
|:------:|:----------:|
| 170  | 0        |
| 45   | 5        |
| 75   | 5        |
| 90   | 0        |
| 2    | 2        |
| 802  | 2        |
| 24   | 4        |
| 66   | 6        |

پس از مرتب‌سازی پایدار بر اساس رقم یکان:
```
[170, 90, 2, 802, 24, 45, 75, 66]
```

#### مرحله ۲: مرتب‌سازی بر اساس رقم دهگان (10¹)

| عدد  | رقم دهگان |
|:------:|:-----------:|
| 170  | 7         |
| 90   | 9         |
| 2    | 0         |
| 802  | 0         |
| 24   | 2         |
| 45   | 4         |
| 75   | 7         |
| 66   | 6         |

پس از مرتب‌سازی پایدار بر اساس رقم دهگان:
```
[2, 802, 24, 45, 66, 170, 75, 90]
```

#### مرحله ۳: مرتب‌سازی بر اساس رقم صدگان (10²)

| عدد  | رقم صدگان |
|:------:|:-----------:|
| 2    | 0          |
| 802  | 8          |
| 24   | 0          |
| 45   | 0          |
| 66   | 0          |
| 170  | 1          |
| 75   | 0          |
| 90   | 0          |

پس از مرتب‌سازی پایدار بر اساس رقم صدگان:
```
‭[2, 24, 45, 66, 75, 90, 170, 802]‬
```

✅ **نتیجه نهایی:** `‭[2, 24, 45, 66, 75, 90, 170, 802]‬`

> 💡 پایداری تضمین می‌کند که اعداد با رقم یکسان، ترتیب نسبی خود را حفظ کنند.

---

### 🧠 چرا از مرتب‌سازی شمارشی برای هر رقم استفاده می‌شود؟

◻️ مرتب‌سازی شمارشی **پایدار** است — برای کارکرد صحیح رادیکس ضروری است

◻️ در **O(n + k)** اجرا می‌شود، که `k = 10` (ارقام ۰ تا ۹)

◻️ بنابراین زمان کل: **O(d × (n + 10)) = O(d × n)**

---

### 📊 خلاصه مراحل

| هدف | مرحله |
|--------:|------:|
| تعیین تعداد رقم‌ها `d` | 1️⃣ پیدا کردن ماکسیمم |
| از LSD به MSD | 2️⃣ حلقه روی رقم‌ها |
| استفاده از مرتب‌سازی شمارشی | 3️⃣ مرتب‌سازی پایدار بر اساس هر رقم |
| آرایه نهایی کاملاً مرتب شده است | 4️⃣ ترکیب |
<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/radix-sort/python/radix_sort.py) | [Java](/sorting/radix-sort/java/RadixSort.java) | [JavaScript](/sorting/radix-sort/javascript/radix-sort.js) | [C++](/sorting/radix-sort/C++/radix_sort.cpp) | [C#](/sorting/radix-sort/csharp/RadixSort.cs)