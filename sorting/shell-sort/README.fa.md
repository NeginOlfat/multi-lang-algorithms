اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/shell-sort/README.md)

# 🟠 الگوریتم مرتب‌سازی شِل

یک الگوریتم مرتب‌سازی **مقایسه‌ای و درجا** است که **[مرتب‌سازی درجی](/sorting/insertion-sort/README.fa.md)** را تعمیم می‌دهد و با جابه‌جایی عناصری که فاصله زیادی از هم دارند، کار می‌کند. این روش ابتدا عناصر دوردست را مرتب می‌کند و به تدریج فاصله («گِپ») را کاهش می‌دهد تا زمانی که به ۱ برسد — در این مرحله رفتار الگوریتم مانند مرتب‌سازی درجی خواهد بود.

مرتب‌سازی شِل یکی از قدیمی‌ترین الگوریتم‌های مرتب‌سازی (مطرح شده توسط دونالد شِل در سال ۱۹۵۹) است و به دلیل **عملکرد خوب متوسط** و **مصرف کم حافظه**، همچنان در عمل کاربرد دارد.

## 📈 پیچیدگی زمانی

| حالت       | زمان               |
|:-----------:|:--------------------:|
| بهترین    | O(n log n)         |
| متوسط     | O(n^1.3) تقریباً   |
| بدترین   | O(n²)              |

> ⏱️ عملکرد واقعی به شدت به **دنباله گِپ** استفاده شده بستگی دارد.

| دنباله گِپ       | بدترین حالت زمانی     |
|:--------------------:|---------------------|
| اصلی شِل           | O(n²)               |
| کنوت (1973)        | O(n^1.5)            |
| سِدجِویک           | O(n^1.3)            |
| پرات               | O(n log² n)         |

## 💾 پیچیدگی فضایی
- **O(1)** — مرتب‌سازی درجا انجام می‌شود و فقط چند متغیر اضافی نیاز دارد

## ✅ چه زمانی از آن استفاده کنیم؟
◻️ ✅ داده‌های کوچک تا متوسط (< ۵,۰۰۰ عنصر)

◻️ ✅ زمانی که حافظه محدود است (سیستم‌های تعبیه‌شده)

◻️ ✅ به عنوان **زیرالگوریتم** در الگوریتم‌های ترکیبی

◻️ ✅ زمانی که یک مرتب‌سازی ساده، غیربازگشتی و درجا نیاز داریم

🚫 مناسب نیست برای:

◻️ داده‌های بسیار بزرگ (از Merge Sort، Quick Sort یا Heap Sort استفاده کنید)

◻️ زمانی که عملکرد تضمینی O(n log n) مطلوب باشد

◻️ سیستم‌های بلادرنگ (به دلیل عملکرد متغیر)

## 🔄 نحوه کارکرد

### 🧩 شبه‌کد

```
BEGIN ShellSort(array)
    n ← length(array)
    gap ← 1

    // انتخاب گِپ اولیه با دنباله کنوت: 1, 4, 13, 40, ...
    WHILE gap < n / 3
        gap ← gap * 3 + 1
    END WHILE

    // کاهش تدریجی گِپ تا صفر
    WHILE gap > 0
        // انجام مرتب‌سازی درجی با گِپ
        FOR i ← gap TO n - 1
            temp ← array[i]
            j ← i

            // جابه‌جایی عناصر با فاصله گِپ تا پیدا شدن مکان صحیح
            WHILE j >= gap AND array[j - gap] > temp
                array[j] ← array[j - gap]
                j ← j - gap
            END WHILE

            array[j] ← temp
        END FOR

        // کاهش گِپ (کنوت: h = (h - 1) / 3)
        gap ← (gap - 1) / 3
    END WHILE
END
```

> 🔍 توجه: **دنباله گِپ** تأثیر زیادی بر عملکرد دارد. دنباله کنوت (`1, 4, 13, 40, ...`) اغلب استفاده می‌شود.

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم: `‭[64, 34, 25, 12, 22, 11, 90]‬`

از **دنباله گِپ کنوت** استفاده می‌کنیم:  
بزرگ‌ترین گِپ کوچک‌تر از `n/3` را انتخاب می‌کنیم ← `gap = 4`، سپس به `1` کاهش می‌یابد.

#### مرحله ۱: گِپ = ۴

عناصر را از ایندکس ۴ شروع می‌کنیم و هر کدام را در زیرآرایه با گِپ ۴ درج می‌کنیم:

◻️  اول ایندکس ۴،  **`i = 4 (مقدار = 22)`**: با `arr[0] = 64` مقایسه می‌شود ← چون `22 < 64` است، جابه‌جایی انجام می‌شود ←  
  ← `‭[22, 34, 25, 12, 64, 11, 90]‬`


◻️ و سپس ایندکس ۵،  **`i = 5 (مقدار = 11)`**: با `arr[1] = 34` مقایسه می‌شود ← چون `11 < 34` است، جابه‌جایی انجام می‌شود ←  
  ← `‭[22, 11, 25, 12, 64, 34, 90]‬`

◻️  و در آخر ایندکس ۶،  **`i = 6 (مقدار = 90)`**: با `arr[2] = 25` مقایسه می‌شود ← چون `90 > 25` است، جابه‌جایی نمی‌شود

✅ آرایه پس از گِپ=۴: `‭[22, 11, 25, 12, 64, 34, 90]‬`

#### مرحله ۲: گِپ = ۱

اکنون **مرتب‌سازی درجی** را روی کل آرایه انجام می‌دهیم:

```
شروع:
       ‭[22, 11, 25, 12, 64, 34, 90]‬

i=1: 11 ← قبل از 22 قرار می‌گیرد ← ‭[11, 22, 25, 12, 64, 34, 90]‬
i=2: 25 ← در جای خود است
i=3: 12 ← بین 11 و 22 قرار می‌گیرد ← ‭[11, 12, 22, 25, 64, 34, 90]‬
i=4: 64 ← در جای خود است
i=5: 34 ← بین 25 و 64 قرار می‌گیرد ← ‭[11, 12, 22, 25, 34, 64, 90]‬
i=6: 90 ← در جای خود است
```

✅ نتیجه نهایی: `‭[11, 12, 22, 25, 34, 64, 90]‬`

> 💡 مرتب‌سازی شِل با نزدیک کردن سریع عناصر دوردست، تعداد جابه‌جایی‌ها و مقایسه‌ها را کاهش می‌دهد.

## 🧠 چرا مرتب‌سازی شِل کار می‌کند؟

◻️ **مرتب‌سازی درجی** روی آرایه‌های **تقریباً مرتب** بسیار کارآمد است.

◻️ با مرتب کردن با گِپ بزرگ، آرایه **به صورت جزئی مرتب** می‌شود.

◻️ هر گِپ کوچک‌تر، ترتیب را بیشتر بهبود می‌دهد.

◻️ مرحله نهایی (گِپ=۱) بسیار سریع اجرا می‌شود.

---

### 📊 خلاصه مراحل

| هدف | مرحله |
|--------:|------:|
| از مقدار بزرگ شروع کن و به تدریج کاهش بده | 1️⃣ انتخاب دنباله گِپ |
| عناصر با فاصله `gap` را مرتب کن | 2️⃣ مرتب‌سازی درجی با گِپ |
| تا زمانی که گِپ = ۱ شود تکرار کن | 3️⃣ کاهش گِپ |
| با گِپ=۱ تمیزکاری کن | 4️⃣ مرتب‌سازی نهایی درجی |
<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/shell-sort/python/shell_sort.py) | [Java](/sorting/shell-sort/java/ShellSort.java) | [JavaScript](/sorting/shell-sort/javascript/shell-sort.js) | [C++](/sorting/shell-sort/C++/shell_sort.cpp) | [C#](/sorting/shell-sort/csharp/ShellSort.cs)
