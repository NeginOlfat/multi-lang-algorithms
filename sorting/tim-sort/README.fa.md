اِین صفحه را به زبان‌های دیگر بخوانید: [English](/sorting/tim-sort/README.md)

# 🟢 الگوریتم مرتب‌سازی تیم

یک الگوریتم مرتب‌سازی **ترکیبی**, **پایدار** و **خودسازگار** است که از **ادغامی** و **درجی** گرفته شده و برای عملکرد عالی روی داده‌های دنیای واقعی طراحی شده است.

این الگوریتم توسط **تیم پیترز** در سال ۲۰۰۲ برای **زبان برنامه‌نویسی پایتون** اختراع شد و اکنون در سیستم‌های زیر استفاده می‌شود:

​◻️ ✅ `sorted()` و `list.sort()` در پایتون

​◻️ ✅ `Arrays.sort()` در جاوا برای اشیا

​◻️ ✅ SDK اندروید

​◻️ ✅ موتور جاوااسکریپت V8

> 💡 مرتب‌سازی تیم **فقط سریع نیست** — **هوشمند** هم هست: با توجه به ترتیب موجود در داده‌ها تطبیق می‌یابد و روی داده‌های **تقریباً مرتب**, **معکوس**, یا **دنیای واقعی** بسیار کارآمد عمل می‌کند.

## 📈 پیچیدگی زمانی

| حالت       | زمان         |
|:---------:|:------------:|
| بهترین    | O(n)         |
| متوسط     | O(n log n)   |
| بدترین   | O(n log n)   |

> ⏱️ بهترین حالت: وقتی داده از قبل مرتب یا معکوس باشد  
> ⏱️ بدترین حالت: همچنان O(n log n) — بهتر از مرتب‌سازی سریع

## 💾 پیچیدگی فضایی
​◻️ **O(n)** — به فضای کمکی برای ادغام نیاز دارد

## ✅ چه زمانی از آن استفاده کنیم؟
​◻️ ✅ مرتب‌سازی **داده‌های دنیای واقعی** با ترتیب طبیعی (مثلاً لاگ‌ها، ورودی کاربر)

​◻️ ✅ نیاز به **مرتب‌سازی پایدار** داریم (ترتیب نسبی عناصر برابر حفظ شود)

​◻️ ✅ مرتب‌سازی **اشیا** یا داده‌های پیچیده

​◻️ ✅ می‌خواهیم از **عملکرد یک مرتب‌سازی کتابخانه‌ای** استفاده کنیم

🚫 مناسب نیست برای:

​◻️ محیط‌های با حافظه محدود (به دلیل فضای O(n))

​◻️ سیستم‌های تعبیه‌شده

​◻️ آموزش مرتب‌سازی پایه (برای مبتدیان بسیار پیچیده است)

## 🔄 نحوه کارکرد

مرتب‌سازی تیم بهترین بخش‌های **مرتب‌سازی درجی** (سریع روی آرایه‌های کوچک) و **ادغامی** (پایدار، O(n log n)) را به همراه بهینه‌سازی‌های هوشمندانه ترکیب می‌کند: 

### 1. **تقسیم به قطعات (Runs)**
​◻️ آرایه را اسکن کرده و **قطعات یکنواخت** (دنباله‌های صعودی یا نزولی کامل) را شناسایی می‌کند.

​◻️ قطعات نزولی را معکوس می‌کند تا صعودی شوند.

​◻️ اگر یک قطعه خیلی کوتاه باشد، آن را با استفاده از **مرتب‌سازی درجی** تا طول حداقلی (`minrun`) گسترش می‌دهد.

### 2. **انتخاب `minrun`**
​◻️ اندازه‌ای کوچک (۳۲ تا ۶۴) است که بر اساس اندازه آرایه انتخاب می‌شود تا تعادل بین کارایی ادغام حفظ شود.

​◻️ تعداد قطعات را نزدیک به توانی از ۲ نگه می‌دارد تا ادغام بهینه باشد.

### 3. **قرار دادن قطعات در پشته**
​◻️ یک پشته از قطعات نگه می‌دارد که دو شرط زیر را رعایت می‌کنند:

  ◽ `run[-3] > run[-2] + run[-1]`
  
  ◽ `run[-2] > run[-1]`

​◻️ این شرایط از ادغام‌های نامتعادل جلوگیری کرده و عملکرد O(n log n) را تضمین می‌کنند.

### 4. **ادغام قطعات وقتی شرایط شکسته شوند**
◻️ وقتی شرایط بالا نقض شوند، قطعات را از پشته ادغام می‌کند.

◻️ در حین ادغام از **حالت پرشی (galloping mode)** استفاده می‌کند تا عناصر را سریع رد کند وقتی یک قطعه به طور مداوم کوچک‌تر باشد.

### 5. **ادغام نهایی**
◻️ پس از پردازش تمام عناصر، تمام قطعات باقی‌مانده را به یک آرایه مرتب تبدیل می‌کند.

---

### 🔄 مثال گام به گام

آرایه زیر را مرتب می‌کنیم:  
`‭[10, 9, 8, 7, 15, 16, 17, 3, 2, 1, 12, 13, 14, 18, 19, 20]‬`

این آرایه شامل موارد زیر است:

◻️ یک قطعه نزولی: `‭[10, 9, 8, 7]‬`

◻️ یک قطعه صعودی: `‭[15, 16, 17]‬`

◻️ یک قطعه نزولی دیگر: `‭[3, 2, 1]‬`

◻️ یک قطعه صعودی بلند: `‭[12, 13, 14, 18, 19, 20]‬`

این داده **ایده‌آل برای مرتب‌سازی تیم** است — این الگوریتم می‌تواند از **همه ترتیب‌های موجود** بهره ببرد.

---

#### 🔢 مرحله ۱: محاسبه `minrun`

برای `n = 16`، مرتب‌سازی تیم `minrun` را به این صورت محاسبه می‌کند:

1▫️ پنج بیت بالایی `n` را بگیرید (16 = `10000` در مبنای دو)

2▫️ اگر بیت‌های باقی‌مانده غیرصفر بودند، ۱ اضافه کنید

3▫️ نتیجه: `minrun = 16` ← اما این خیلی بزرگ است!

در عمل، `minrun` بین **۳۲ تا ۶۴** محدود می‌شود.  
اما برای این آرایه کوچک، از یک قانون ساده‌شده استفاده می‌کنیم:  

> **`minrun = max(2, min(n/4, 32))`** → `minrun = 4`

✅ بنابراین هر قطعه باید **حداقل ۴ عنصر داشته باشد**.

#### 🔎 مرحله ۲: پیدا کردن و پردازش قطعات

ما از چپ به راست حرکت می‌کنیم و **قطعات یکنواخت** را شناسایی می‌کنیم.

##### 🔹 قطعه ۱: `‭[10, 9, 8, 7]‬` ← نزولی
◻️ به عنوان یک دنباله کاملاً نزولی شناسایی شد.

◻️ معکوس کنید ← `‭[7, 8, 9, 10]‬`

◻️ طول = ۴ ≥ `minrun` ← به پشته اضافه کنید  
  ✅ پشته: `‭[ [7,8,9,10] ]‬`

##### 🔹 قطعه ۲: `‭[15, 16, 17]‬` ← صعودی، اما طول = ۳ < `minrun`
◻️ گسترش دهید با استفاده از **مرتب‌سازی درجی** با عنصر بعدی: `3`

◻️ حالا `‭[15,16,17,3]‬` ← با استفاده از **درجی** مرتب کنید ← `‭[3,15,16,17]‬`

◻️  طول = ۴ ← به پشته اضافه کنید 
  ✅ پشته: `‭[ [7,8,9,10], [3,15,16,17] ]‬`

##### 🔹 قطعه ۳: `‭[2, 1]‬` ← نزولی، طول = ۲ < `minrun`
◻️ معکوس کنید ← `‭[1, 2]‬`

◻️ با عنصر بعدی گسترش دهید: `[12]` ← هنوز کوتاه است

◻️ `[13]` را اضافه کنید ← حالا `‭[1,2,12,13]‬` (طول ۴)

◻️ از قبل مرتب است ← اضافه کنید  
  پشته: `‭[ [7,8,9,10], [3,15,16,17], [1,2,12,13] ]‬`

##### 🔹 قطعه ۴: `‭[14, 18, 19, 20]‬` ← صعودی، طول = ۴ ≥ `minrun`
◻️ بدون تغییر اضافه شود  
  پشته: `‭[ [7,8,9,10], [3,15,16,17], [1,2,12,13], [14,18,19,20] ]‬`

---

#### 🔄 مرحله ۳: ادغام قطعات با استفاده از شرایط پشته

مرتب‌سازی تیم یک پشته از قطعات نگه می‌دارد و دو **شرط** را برای جلوگیری از ادغام نامتعادل اعمال می‌کند:
1. `run[i-3] > run[i-2] + run[i-1]`  
2. `run[i-2] > run[i-1]`

اگر نقض شوند، دو کوچک‌ترین قطعه ادغام می‌شوند.

اجرا کنیم:

##### 🔹 بررسی شرایط
اندازه قطعات: `[4, 4, 4, 4]`

از بالا بررسی کنید:

◻️ `run[-2] > run[-1]` ← `4 > 4` نادرست ❌  ← **ادغام!**

ادغام دو قطعه بالایی: `‭[1,2,12,13]‬` و `‭[14,18,19,20]‬`  
← هر دو صعودی ← ادغام ساده ← `‭[1,2,12,13,14,18,19,20]‬`

پشته جدید: `‭[ [7,8,9,10], [3,15,16,17], [1,2,12,13,14,18,19,20] ]‬`  
اندازه‌ها: `‭[4, 4, 8]‬`

دوباره بررسی:

◻️ `run[-2] > run[-1]` ← `4 > 8` ❌ نادرست ← **ادغام!**

ادغام `‭[3,15,16,17]‬` و `‭[1,2,12,13,14,18,19,20]‬`  
← از **حالت پرشی (galloping mode)** استفاده کنید:

◻️ مقایسه `3` با `1` ← `1` کوچکتر ← اضافه کنید `1` 

◻️ مقایسه `3` با `2` ← `2` کوچکتر ← اضافه کنید `2` 

◻️ حالا `3 < 12` ← اضافه کنید `3`  

◻️ سپس `‭[15,16,17]`‬ را به ترتیب اضافه کنید   

◻️ سپس بقیه را اضافه کنید

نتیجه: `‭[1,2,3,12,13,14,15,16,17,18,19,20]‬`

پشته جدید: `‭[ [7,8,9,10], [1,2,3,12,13,14,15,16,17,18,19,20] ]‬`  
اندازه‌ها: `‭[4, 12]‬`

بررسی:

◻️ `4 > 12` ❌ نادرست ← **ادغام!**

ادغام نهایی: `‭[7,8,9,10]‬` + `‭[1,2,3,12,...]‬`  
← پرش: `7 > 2` ← ادامه تا `12` ← قرار دهید `7,8,9,10` قبل از `12`  
← نتیجه: `‭[1,2,3,7,8,9,10,12,13,14,15,16,17,18,19,20]‬`

✅ آرایه نهایی مرتب‌شده:  
`‭[1, 2, 3, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20]‬`

> 💡 مرتب‌سازی تیم از **ترتیب موجود** بهره می‌برد — بدون مقایسه‌های غیرضروری.

---

### 🧠 چرا از مرتب‌سازی تیم استفاده کنیم؟

| الگوریتم | پایدار؟ | خودسازگار؟ | عملکرد دنیای واقعی | استفاده در |
|---------|--------|----------|-----------------|--------|
| مرتب‌سازی سریع | ❌ خیر | ✅ بله | سریع | C, Go |
| مرتب‌سازی ادغامی | ✅ بله | ❌ خیر | قابل پیش‌بینی | کتابخانه‌ها |
| **مرتب‌سازی تیم** | ✅ بله | ✅ بله | ⭐ **بهترین** | **پایتون، جاوا** |

<br/>

◻️ ✅ **پایدار**: ترتیب عناصر برابر را حفظ می‌کند

◻️ ✅ **خودسازگار**: روی داده‌های تقریباً مرتب سریع‌تر است

◻️ ✅ **بهینه برای داده واقعی**: با "قطعات طبیعی" کار می‌کند

◻️ ✅ **تضمین O(n log n)**: بدون بدترین حالت O(n²) مثل مرتب‌سازی سریع

---

### 📊 خلاصه مراحل

| مرحله | هدف |
|------:|--------:|
| 1️⃣ پیدا کردن قطعات | تشخیص ترتیب موجود |
| 2️⃣ گسترش قطعات کوتاه | استفاده از درجی برای رسیدن به `minrun` |
| 3️⃣ ادغام با شرایط پشته | جلوگیری از ادغام نامتعادل |
| 4️⃣ ادغام پرشی | رد کردن سریع عناصر در حین ادغام |
| 5️⃣ ادغام نهایی | تولید خروجی مرتب |

<br />

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/sorting/tim-sort/python/tim_sort.py) | [Java](/sorting/tim-sort/java/TimSort.java) | [JavaScript](/sorting/tim-sort/javascript/tim-sort.js) | [C++](/sorting/tim-sort/C++/tim_sort.cpp) | [C#](/sorting/tim-sort/csharp/TimSort.cs)
