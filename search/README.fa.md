اِین صفحه را به زبان‌های دیگر بخوانید: [English](/search/README.md)


# 🔍 الگوریتم‌های جستجو

الگوریتم‌های جستجو ابزارهای ضروری برای یافتن داده به‌صورت کارآمد در ساختارهای داده مانند آرایه‌ها، لیست‌ها، درخت‌ها، گراف‌ها و رشته‌ها هستند. این مخزن پیاده‌سازی‌هایی تمیز و مستند از الگوریتم‌های کلیدی جستجو را با توضیحات و تحلیل پیچیدگی زمانی و حافظه ارائه می‌دهد.


## 🧩 الگوریتم‌های پوشش داده شده

### 🔢 الگوریتم‌های جستجوی مبتنی بر آرایه

1▫️ [**جستجوی خطی**](/search/array-based-search/linear-search/README.fa.md): هر عنصر را یکی یکی بررسی می‌کند تا هدف پیدا شود یا به انتها برسد.

2▫️ [**جستجوی دودویی**](/search/array-based-search/binary-search/README.fa.md): آرایه مرتب را به طور مداوم نصف می‌کند تا هدف را پیدا کند.

3▫️ [**جستجوی پرشی**](/search/array-based-search/jump-search/README.fa.md): با پرش در گام‌های ثابت، بلوک مناسب را پیدا کرده و سپس جستجوی خطی انجام می‌دهد (روی آرایه‌های مرتب).

4▫️ [**جستجوی درون‌یابی**](/search/array-based-search/interpolation-search/README.fa.md): موقعیت عنصر هدف را با استفاده از توزیع مقادیر تخمین می‌زند (بهترین عملکرد در داده‌های یکنواخت).

5▫️ [**جستجوی نمایی**](/search/array-based-search/exponential-search/README.fa.md): با استفاده از توان‌های دو، بازه‌ای که عنصر ممکن است در آن باشد را پیدا کرده و سپس از جستجوی دودویی استفاده می‌کند.

6▫️ [**جستجوی سه‌گانه**](/search/array-based-search/ternary-search/README.fa.md): آرایه مرتب یک‌نما را به سه قسمت تقسیم می‌کند تا کمینه/بیشینه یا مقدار هدف را پیدا کند.

7▫️ **جستجوی فیبوناچی**: مشابه جستجوی دودویی، اما از اعداد فیبوناچی برای تقسیم آرایه استفاده می‌کند.

8▫️ **جستجوی سنوتل (Sentinel)**: نوعی جستجوی خطی که با قرار دادن یک علامت‌گذار (سنوتل) در انتها، بررسی مرزها را حذف می‌کند.

9▫️ **جستجوی خودسازمان‌دهی**: پس از هر دسترسی، لیست را بر اساس فراوانی دسترسی تنظیم می‌کند (مثل حرکت به جلو).

10▫️ **جستجوی دودویی روی پاسخ**: جستجوی دودویی روی محدوده‌ای از پاسخ‌های ممکن انجام می‌دهد (متداول در مسائل بهینه‌سازی).

---

### 🌳 الگوریتم‌های جستجوی درخت

1▫️ **پیمایش میان‌ترتیب (DFS)**: زیردرخت چپ، ریشه، سپس زیردرخت راست را ملاقات می‌کند (برای درخت‌های دودویی). 

2▫️ **پیمایش پیش‌ترتیب (DFS)**: ابتدا ریشه، سپس زیردرخت‌های چپ و راست را به صورت بازگشتی ملاقات می‌کند. 

3▫️ **پیمایش پس‌ترتیب (DFS)**: ابتدا زیردرخت‌های چپ و راست، سپس ریشه را ملاقات می‌کند. 

4▫️ **پیمایش سطح‌به‌سطح (BFS)**: گره‌ها را از بالا به پایین و سطح به سطح با استفاده از صف ملاقات می‌کند. 

5▫️ **جستجوی عمق اول (DFS)**: تا حد امکان در یک شاخه پیش می‌رود و سپس بازمی‌گردد. 

6▫️ **جستجوی عمق افزایشی تکراری (IDDFS)**: DFS را با محدودیت عمق افزایشی انجام می‌دهد تا مزایای عمق و عرض را ترکیب کند. 

---

### 🔗 الگوریتم‌های جستجوی گراف

1▫️ **جستجوی سطح اول (BFS)**: تمام همسایه‌های سطح فعلی را قبل از حرکت به سطح بعدی بررسی می‌کند (کوتاه‌ترین مسیر در گراف‌های بدون وزن).

2▫️ **جستجوی عمق اول (DFS)**: تا حد امکان در یک شاخه پیش می‌رود و سپس بازمی‌گردد (قابل تشخیص دور یا مؤلفه‌ها).

3▫️ **الگوریتم دایکسترا**: کوتاه‌ترین مسیر از یک منبع به تمام رئوس را در گراف وزن‌دار با وزن‌های نامنفی پیدا می‌کند.

4▫️ **جستجوی \*A**: از هیوریستیک (heuristic) برای راهنمایی یافتن مسیر در گراف‌های وزن‌دار استفاده می‌کند (بهینه اگر هیوریستیک قابل قبول باشد).

5▫️ **الگوریتم بلمن-فورد**: کوتاه‌ترین مسیرها را حتی با وزن‌های منفی محاسبه می‌کند (دورهای منفی را تشخیص می‌دهد).

6▫️ **الگوریتم فلوید-وارشال**: کوتاه‌ترین مسیرها بین تمام جفت‌های گره‌ها را محاسبه می‌کند.

7▫️ **الگوریتم پریم**: درخت پوشای کمینه را با افزودن یال‌های کم‌هزینه گسترش می‌دهد.

8▫️ **الگوریتم کروسکال**: درخت پوشای کمینه را با افزودن کوچک‌ترین یال‌ها و بدون ایجاد دور می‌سازد.

9▫️ **مرتب‌سازی توپولوژیک**: گره‌ها را در یک گراف جهت‌دار بدون دور (DAG) بر اساس وابستگی‌ها مرتب می‌کند.

10▫️ **الگوریتم ترجان**: مؤلفه‌های قویاً همبند در یک گراف جهت‌دار را با استفاده از DFS پیدا می‌کند.

11▫️ **الگوریتم کساراجو**: الگوریتم دیگری برای یافتن مؤلفه‌های قویاً همبند در گراف (دو عبور DFS).

12▫️ **جستجوی دوطرفه**: دو جستجوی همزمان از نقطه شروع و هدف، که در وسط ملاقات می‌کنند.

---


### 🧠 جستجوی هوش مصنوعی

#### **الگوریتم‌های جستجوی ناآگاهانه (بدون هیوریستیک)**

> از دانش حوزه خاصی استفاده نمی‌کنند (بدون هیوریستیک).


1▫️ **جستجوی سطح اول (BFS)** – تمام گره‌های سطح فعلی را قبل از عمق‌تر شدن بررسی می‌کند (در گراف‌های بدون وزن کوتاه‌ترین مسیر را تضمین می‌کند).


2▫️ **جستجوی عمق اول (DFS)** – تا حد امکان در یک مسیر پیش می‌رود و سپس بازمی‌گردد.


3▫️ **جستجوی هزینه یکنواخت (UCS)** – گرهی با کمترین هزینه مسیر را بسط می‌دهد (در صورت وجود هزینه مختلف، بهینه است).


4▫️ **جستجوی عمق محدود**: نسخه‌ای از DFS که عمق بازگشتی را محدود می‌کند تا از مسیرهای نامتناهی جلوگیری کند.


5▫️ **جستجوی عمق افزایشی تکراری (IDDFS)** – DFS را با محدودیت عمق افزایشی تکرار می‌کند تا کارایی حافظه DFS و کامل‌بودن BFS را ترکیب کند.


6▫️ **جستجوی دوطرفه**: دو جستجوی همزمان از شروع و هدف را اجرا می‌کند و در وسط ملاقات می‌کنند (فضای جستجو را کاهش می‌دهد).


#### 🧠 **الگوریتم‌های جستجوی آگاهانه (با هیوریستیک)**

> از هیوریستیک برای تصمیم‌گیری هوشمندانه‌تر و هدایت جستجو به سمت هدف استفاده می‌کنند.


7▫️ **جستجوی بهترین حرکت حریصانه (Greedy Best-First)** – گرهی که به نظر نزدیک‌تر به هدف است را انتخاب می‌کند (همیشه بهینه نیست).


8▫️ **جستجوی \*A** – هزینه مسیر و هیوریستیک را ترکیب می‌کند تا به‌طور کارآمد مسیر بهینه را پیدا کند (بهینه اگر هیوریستیک قابل قبول باشد).


9▫️ **جستجوی \*A تکراری عمیق‌شونده (\*IDA)** – نسخه‌ای کارآمد از نظر حافظه از \*A که از حد هزینه افزایشی استفاده می‌کند.

10▫️ **جستجوی \*A محدودشده توسط حافظه** (مثلاً **\*SMA**, **RBFS**): انواعی از \*A که محدودیت‌های حافظه را مدیریت می‌کنند.


#### 🎯 **الگوریتم‌های جستجوی محلی و بهینه‌سازی**

> معمولاً برای فضاهای تک‌حالتی یا پیوسته استفاده می‌شوند (نه پیمایش درخت/گراف).

11▫️ **تپه‌نوردی (Hill Climbing)**: به صورت تکراری به همسایه‌ای با مقدار بهتر حرکت می‌کند (ممکن است در بهینه محلی گیر کند).

12▫️ **شبیه سازی تبرید (Simulated Annealing)**: گاهی حرکت‌های بدتر را می‌پذیرد تا از بهینه‌های محلی فرار کند؛ شبیه فرآیند فیزیکی.

13▫️ **الگوریتم ژنتیک**: راه‌حل‌ها را با انتخاب، تقاطع و جهش تکامل می‌دهد (الهام‌گرفته از تکامل بیولوژیکی).

14▫️ **جستجوی بیم (Beam Search)**: فقط `k` کاندید بهترین را در هر سطح نگه می‌دارد و مصرف حافظه را کاهش می‌دهد.

15▫️ **تپه‌نوردی تصادفی (Stochastic Hill Climbing)**:  از بین حرکت‌های بهتر به صورت تصادفی انتخاب می‌کند، نه الزاماً شیب‌ترین.

16▫️ **تپه‌نوردی با شروع تصادفی (Random Restart Hill Climbing)**: تپه‌نوردی را از نقاط شروع تصادفی تکرار می‌کند تا از ماکسیمم‌های محلی فرار کند.


#### 🎮 **الگوریتم‌های جستجوی بازی**

> در محیط‌های دو نفره یا دشمن‌وار استفاده می‌شوند (استراتژی‌های مینی‌ماکس).

17▫️ **الگوریتم Minimax**: حرکت بهینه را با فرض بازی بهینه حریف انتخاب می‌کند (در بازی‌های اطلاعات کامل استفاده می‌شود).

18▫️ **برش آلفا-بتا (Alpha-Beta Pruning)** – Minimax را با حذف شاخه‌هایی که بر نتیجه نهایی تأثیر نمی‌گذارند، بهینه می‌کند.

19▫️ **اِکسپِکتی‌مکس (Expectimax)** – مثل minimax اما اتفاقات احتمالی را در نظر می‌گیرد (مثلاً در بازی‌های شامل شانس).

20▫️ **جستجوی درخت مونت کارلو (MCTS)** – با شبیه‌سازی‌های تصادفی متعدد از وضعیت فعلی، تصمیمات آماری مطلع می‌گیرد.


---

### 🔤 جستجوی رشته

1▫️ **جستجوی ساده**: هر موقعیت در متن را برای یافتن الگو بررسی می‌کند.

2▫️ **الگوریتم KMP**: از جدول پیشوند برای رد کردن مقایسه‌های غیرضروری استفاده می‌کند.

3▫️ **الگوریتم بویر مور**: از راست به چپ مقایسه می‌کند و از هیوریستیک‌های کاراکتر بد و قانون پسوند  خوب برای پرش جلوتر استفاده می‌کند.

4▫️ **الگوریتم رابین-کارپ**: از هَش برای یافتن تطابق الگو در زمان متوسط خطی استفاده می‌کند.

5▫️ **الگوریتم آهو-کوراسیک**: چندین الگو را همزمان با استفاده از درخت سه‌تایی و لینک‌های خطا پیدا می‌کند.

6▫️ **الگوریتم Z**: یک آرایه Z محاسبه می‌کند تا در زمان خطی الگو را بیابد.

7▫️ **الگوریتم سان دی**: از اطلاعات کاراکتر بعدی پنجره جاری برای پرش جلوتر استفاده می‌کند.

8▫️ **تطبیق‌کننده ماشین متناهی**: از یک ماشین حالت پیش‌محاسبه شده برای جستجوی سریع استفاده می‌کند.

9▫️ **الگوریتم Shift-Or / Bitap**: از عملیات بیتی برای تطابق تقریبی یا دقیق رشته استفاده می‌کند.

10▫️ **درخت پسوند (Suffix Tree)**: ساختار داده‌ای که امکان جستجوی زیررشته را فراهم می‌کند.

11▫️ **آرایه پسوند (Suffix Array)**: آرایه مرتبی از پسوندها برای جستجوی کارآمد زیررشته.

12▫️ **جستجوی دوطرفه رشته (Two-Way String Matching)**: الگو را تقسیم می‌کند تا از دوره‌ای بودن برای جستجوی کارآمد استفاده کند.

13▫️ **الگوریتم Wu-Manber**: برای جستجوی چندالگو با فیلتر هَشی طراحی شده است.



## ⏱️ مقایسه پیچیدگی

**جستجوهای مبتنی بر آرایه**
| توضیحات | حافظه | زمان (بدترین حالت) | زمان (میانگین) | الگوریتم |
|---------|-------|---------------------|----------------|----------|
| ساده، روی داده‌های نامرتب کار می‌کند | O(1) | O(n) | O(n) | جستجوی خطی |
| فقط برای داده‌های مرتب | O(1) | O(log n) | O(log n) | جستجوی دودویی |
| مبتنی بر بلوک؛ سریع‌تر از خطی | O(1) | O(√n) | O(√n) | جستجوی پرشی |
| بهترین عملکرد در داده‌های یکنواخت | O(1) | O(n) | O(log log n) | جستجوی درون‌یابی |
| برای آرایه‌های بزرگ/ناشناخته کارآمد است | O(1) | O(log n) | O(log n) | جستجوی نمایی |
| برای آرایه‌ها/توابع یک‌نما | O(1) | O(log₃ n) | O(log₃ n) | جستجوی سه‌گانه |
| جایگزین کارآمد از نظر کش برای جستجوی دودویی | O(1) | O(log n) | O(log n) | جستجوی فیبوناچی |
| بهبود ثابت نسبت به جستجوی خطی | O(1) | O(n) | O(n) | جستجوی سنوتل |


---

<br /><br />

 **جستجوی درخت و گراف** 
| توضیحات | حافظه | زمان (بدترین حالت) | زمان (میانگین) | الگوریتم |
|---------|-------|---------------------|----------------|----------|
| کوتاه‌ترین مسیر در گراف‌های بدون وزن | O(V) | O(V + E) | O(V + E) | BFS |
| یافتن مسیر، تشخیص دور | O(V) | O(V + E) | O(V + E) | DFS |
| ترکیب کارایی حافظه DFS و کامل‌بودن BFS | O(bd) | O(b^d) | O(b^d) | IDDFS |
| فقط برای وزن‌های نامنفی | O(V) | O((V + E) log V) | O((V + E) log V) | دایکسترا |
| وزن‌های منفی را پشتیبانی می‌کند؛ دورهای منفی را تشخیص می‌دهد | O(V) | O(VE) | O(VE) | بلمن-فورد |
| کوتاه‌ترین مسیرها بین تمام جفت‌ها | O(V²) | O(V³) | O(V³) | فلوید-وارشال |
| بهینه با هیوریستیک قابل قبول | O(b^d) | O(b^d) | O(b^d) | جستجوی A* |
| درخت پوشای کمینه | O(V) | O(E log V) | O(E log V) | پریم |
| MST با Union-Find | O(V) | O(E log E) | O(E log E) | کروسکال |
| فقط برای DAG | O(V) | O(V + E) | O(V + E) | مرتب‌سازی توپولوژیک |
| مؤلفه‌های قویاً همبند | O(V) | O(V + E) | O(V + E) | ترجان / کساراجو |
| سریع‌تر از BFS در عمل | O(b^{d/2}) | O(b^{d/2}) | O(b^{d/2}) | جستجوی دوطرفه |


---

<br /><br />

 **جستجوی رشته** 
| توضیحات | حافظه | زمان (بدترین حالت) | زمان (میانگین) | الگوریتم |
|---------|-------|---------------------|----------------|----------|
| ساده اما کند در بدترین حالت | O(1) | O(nm) | O(n + m) | جستجوی ساده |
| بدون بازگشت در متن | O(m) | O(n + m) | O(n + m) | KMP |
| در عمل سریع است | O(m) | O(nm) بدترین | O(n/m) میانگین | بویر مور |
| مناسب برای جستجوی چندالگو | O(m) | O(nm) بدترین | O(n + m) میانگین | رابین-کارپ |
| چندین الگو (z = تعداد تطابق‌ها) | O(mz) | O(n + m + z) | O(n + m + z) | آهو-کوراسیک |
| پرس‌وجوهای سریع زیررشته | O(n) پیش‌پردازش | O(m) | O(m) جستجو | درخت پسوند |
| جایگزین کم‌حافظه برای درخت پسوند | O(n) | O(m log n) | O(m log n) | آرایه پسوند |


---

<br /><br />

 **هوش مصنوعی و جستجوی محلی** 
| توضیحات | حافظه | زمان (بدترین حالت) | زمان (میانگین) | الگوریتم |
|---------:|-------:|---------------------:|----------------:|----------:|
| بهینه نیست؛ به هیوریستیک بستگی دارد | O(bm) | O(b^m) | O(b^m) | جستجوی بهترین حرکت حریصانه |
| بهینه؛ گره کم‌هزینه را بسط می‌دهد | O(b^{C*/ε}) | O(b^{C*/ε}) | O(b^{C*/ε}) | هزینه یکنواخت |
| بهینه و کامل با هیوریستیک قابل قبول | O(b^d) | O(b^d) | O(b^d) | جستجوی A* |
| نسخه کارآمد از نظر حافظه از A* | O(d) | O(b^d) | O(b^d) | IDA* |
| سریع اما ممکن است در ماکسیمم محلی گیر کند | O(1) | - | - | تپه‌نوردی |
| می‌تواند به صورت احتمالی از ماکسیمم‌های محلی فرار کند | O(1) | - | - | شبیه سازی تبرید |
| در بازی‌های پیچیده مانند گو استفاده می‌شود | O(N) | - | بستگی به شبیه‌سازی‌ها دارد | MCTS |

---

<br /> 

> `n`: اندازه داده/متن، `m`: طول الگو، `V`: تعداد رأس‌ها، `E`: تعداد یال‌ها، `b`: فاکتور شاخه‌بندی، `d`: عمق، `C*`: هزینه راه‌حل بهینه، `ε`: دقت هزینه گام