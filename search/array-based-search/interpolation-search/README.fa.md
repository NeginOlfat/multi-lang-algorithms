اِین صفحه را به زبان‌های دیگر بخوانید: [English](/search/array-based-search/interpolation-search/README.md)

# 🔍 جستجوی درون‌یابی – جستجوی هوشمند برای داده‌های یکنواخت

**جستجوی درون‌یابی** یک نسخه بهبودیافته از **جستجوی دودویی** است که به‌طور کارآمد روی **آرایه‌های مرتب با مقادیر به‌صورت یکنواخت توزیع‌شده** کار می‌کند. به جای تقسیم همیشگی فضای جستجو به دو قسمت، این روش با استفاده از یک **فرمول ریاضی**، موقعیت مقدار هدف را **تخمین می‌زند** — دقیقاً مثل وقتی که در یک دفترچه تلفن به سراغ بخش "س" می‌روید تا نام "سمیعی" را پیدا کنید.

این ویژگی آن را در شرایط ایده‌آل — به‌ویژه برای مجموعه داده‌های بزرگ و با فواصل منظم — **سریع‌تر از جستجوی دودویی** می‌کند.

## 📚 نحوه کارکرد

برخلاف جستجوی دودویی که همیشه به سمت عنصر میانی حرکت می‌کند، جستجوی درون‌یابی از یک **فرمول موقعیت‌یابی** استفاده می‌کند تا محل احتمالی مقدار هدف را پیش‌بینی کند:

### 🔢 فرمول موقعیت
```text
‭pos = low + [(target - arr[low]) × (high - low) / (arr[high] - arr[low])]‬
```

که در آن:
- `low` = اندیس ابتدای بازه فعلی
- `high` = اندیس انتهای بازه
- `arr[low]`, `arr[high]` = مقادیر در آن اندیس‌ها

### ✅ مراحل:
1▫️ با `‭low = 0‬` و `‭high = n - 1‬` شروع کنید

2▫️ از فرمول برای محاسبه موقعیت تخمینی `pos` استفاده کنید

3▫️ اگر  `‭pos‬`  ←  `‭arr[pos] == target‬` را بازگردانید

4▫️ اگر `‭arr[pos] < target‬` ← در **زیرآرایه سمت راست** جستجو کنید (`‭low = pos + 1‬`)

5▫️ اگر `‭arr[pos] > target‬` ← در **زیرآرایه سمت چپ** جستجو کنید (`‭high = pos - 1‬`)

6▫️ تا زمانی که مقدار پیدا شود یا `‭low ≤ high‬` نباشد، تکرار کنید

> ✅ **شرط لازم**: آرایه باید **مرتب** باشد  
> 💡 بهترین عملکرد زمانی است که داده‌ها **به صورت یکنواخت توزیع شده باشند** (مثلاً: ۱۰، ۲۰، ۳۰، ۴۰...)

### 🧩 مثال

```text
آرایه:
        ‭[10, 20, 30, 40, 50, 60, 70, 80, 90]‬
هدف: 70

مرحله ۱:
  ‬low = 0 → 10‬
  ‬high = 8 → 90‬
  ‬pos = 0 + [(70–10)*(8–0)/(90–10)] = 0 + [60×8/80] = 6‬

بررسی arr[6] = 70 ← پیدا شد!

اندیس: 6
```

در مقایسه با جستجوی دودویی که برای رسیدن به اندیس ۶ به **۳ مرحله** نیاز دارد، جستجوی درون‌یابی آن را در **یک مرحله** پیدا می‌کند!

## ⏱️ پیچیدگی زمانی و حافظه


| توضیح | پیچیدگی | حالت |
|------------:|:-----------:|------:|
| هدف از اول درست حدس زده شود | O(1) | **بهترین حالت** |
| در داده‌های یکنواخت — **بسیار سریع‌تر از O(log n)** | O(log log n) | **حالت متوسط** |
| وقتی داده‌ها یکنواخت نباشند (مثلاً رشد نمایی) | O(n) | **بدترین حالت** |
| نسخه تکراری از فضای ثابت استفاده می‌کند | O(1) | **پیچیدگی حافظه** |


> 📊 بنابراین:  
> `O(log log n)` << `O(log n)` << `O(n)`

💡 این بدین معناست که برای آرایه‌های بزرگ و مرتب با داده‌های یکنواخت (مثل شناسه‌های پایگاه داده یا زمان‌های ثبت شده)، جستجوی درون‌یابی می‌تواند **به‌مراتب سریع‌تر** از جستجوی دودویی باشد.

## ✅ مزایا و معایب

| ✅ مزایا | ❌ معایب |
|-------:|--------:|
| سریع‌تر از جستجوی دودویی در داده‌های یکنواخت (`O(log log n)` در مقابل `O(log n)`) | در داده‌های غیریکنواخت به O(n) تبدیل می‌شود |
| جستجوی هوشمندانه — مقایسه‌های کمتری لازم است | نیازمند داده‌های مرتب است |
| عالی برای مجموعه داده‌های بزرگ | حساس به عدم تقارن در توزیع داده |
| الهام‌گرفته از دنیای واقعی (مثل شهود انسانی) | خطر تقسیم بر صفر وجود دارد اگر `arr[high] == arr[low]` |

> ⚠️ از آن استفاده نکنید اگر:
>
> ◽ داده‌ها خوشه‌ای یا نامتقارن باشند
>
> ◽ مقادیر تکراری زیادی وجود داشته باشد
>
> ◽ داده‌ها واقعاً مرتب یا یکنواخت نباشند

## 🌐 زمان استفاده

◻️ ✅ جستجو در **آرایه‌های مرتب بزرگ** با داده‌های **یکنواخت توزیع‌شده**

◻️ ✅ سیستم‌های ایندکس‌گذاری پایگاه داده

◻️ ✅ محاسبات علمی (داده‌های با فاصله منظم)

◻️ ✅ برنامه‌های حساس به عملکرد که سرعت میانگین مهم است

◻️ ✅ اهداف آموزشی — نشان می‌دهد که چگونه ریاضیات الگوریتم‌ها را بهبود می‌بخشد

> 🚫 برای آرایه‌های کوچک یا توزیع‌های غیرقابل پیش‌بینی توصیه نمی‌شود.

## 🔁 مقایسه با جستجوی دودویی

| جستجوی درون‌یابی | جستجوی دودویی | ویژگی |
|-----------------------:|--------------:|--------:|
| تخمین موقعیت | همیشه وسط | استراتژی جستجو |
| O(log log n) ✅ بهتر | O(log n) | زمان میانگین |
| O(n) ❌ بدتر | O(log n) | بدترین زمان |
| داده‌های یکنواخت | هر نوع داده مرتب | بهترین مورد |
| متوسط (فرمول پیچیده) | بالا | سادگی |


> این الگوریتم را می‌توان **همزاد هوشمند جستجوی دودویی** دانست — در شرایط مناسب درخشان است، اما در شرایط نامناسب قابل اعتماد نیست.

## 💡 تشبیه دنیای واقعی

تصور کنید دنبال "صفحه ۷۰۰" در یک کتاب ۱۰۰۰ صفحه‌ای هستید:

◻️ **جستجوی دودویی**: صفحه ۵۰۰ باز کنید ← کم است ← به ۷۵۰ بروید ← زیاد است ← به ۶۲۵ بروید... (چند مرحله)

◻️ **جستجوی درون‌یابی**: "۷۰۰ از ۱۰۰۰" ← مستقیماً به صفحه ~۷۰۰ بروید ← سریع پیدا شد!

این روش از تناسب استفاده می‌کند، دقیقاً مثل آنچه ما انسان‌ها انجام می‌دهیم.

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/search/array-based-search/interpolation-search/python/) | [Java](/search/array-based-search/interpolation-search/java/) | [JavaScript](/search/array-based-search/interpolation-search/javascript/) | [C++](/search/array-based-search/interpolation-search/cpp/) | [C#](/search/array-based-search/interpolation-search/csharp/)
