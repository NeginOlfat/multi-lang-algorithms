اِین صفحه را به زبان‌های دیگر بخوانید: [English](/search/array-based-search/ternary-search/README.md)

# 🔍 جستجوی سه‌گانه – تقسیم به سه قسمت برای بهینه‌سازی

**جستجوی سه‌گانه** یک الگوریتم جستجو است که عمدتاً برای یافتن **بیشینه یا کمینه** یک **تابع یک‌نما** (تابعی که ابتدا افزایش و سپس کاهش می‌یابد — یا برعکس) در یک بازه مشخص استفاده می‌شود.

برخلاف جستجوی دودویی که فضای جستجو را به **دو قسمت** تقسیم می‌کند، جستجوی سه‌گانه آن را به **سه قسمت** تقسیم می‌کند و به ما امکان می‌دهد به‌طور کارآمد به سمت نقطه اوج یا فرورفتگی حرکت کنیم.

> 📌 هرچند نسبت به جستجوی دودویی کمتر رایج است، اما در **مسائل بهینه‌سازی**، برنامه‌نویسی رقابتی و مدل‌سازی ریاضی بسیار مفید است.

## 📚 نحوه کارکرد

جستجوی سه‌گانه روی یک **آرایه مرتب** یا یک **تابع پیوسته** که **یک‌نما** باشد کار می‌کند:

◻️​ ابتدا به‌صورت صعودی، سپس نزولی (برای یافتن بیشینه)

◻️​ یا ابتدا نزولی، سپس صعودی (برای یافتن کمینه)

### ✅ مراحل:
1▫️​ بازه جستجو را تعریف کنید: `left` و `right`

2▫️​ دو نقطه میانی را محاسبه کنید:
   - `‭mid1 = left + (right - left) / 3‬`
   - `‭mid2 = right - (right - left) / 3‬`

3▫️​ مقادیر `‭f(mid1)‬` و `‭f(mid2)‬` را مقایسه کنید:
   
   ◻️​ اگر `‭f(mid1) < f(mid2)‬` ← بیشینه در **دو سوم راست** قرار دارد
   
   ◻️​ اگر `‭f(mid1) > f(mid2)‬` ← بیشینه در **دو سوم چپ** قرار دارد

4▫️​ این کار را تا زمانی که بازه به اندازه کافی کوچک شود (با دقت مطلوب) تکرار کنید

> ✅ **شرط لازم**: تابع یا آرایه باید **یک‌نما** باشد

---

### 🧩 مثال: یافتن نقطه اوج در آرایه

```text
آرایه:
        ‭[1, 3, 5, 7, 8, 6, 4, 2]‬

هدف: یافتن اندیس بیشترین مقدار (اوج)

مرحله ۱:
  ‭left = 0, right = 7‬
  ‭mid1 = 2 → arr[2] = 5‬
  ‭mid2 = 5 → arr[5] = 6‬
  چون ۵ < ۶ ← اوج در قسمت راست است 
        ‭→ left = mid1 + 1 ‬

مرحله ۲:
  ‭left = 3, right = 7‬
  ‭mid1 = 4 → arr[4] = 8‬
  ‭mid2 = 6 → arr[6] = 4‬
  چون ۸ > ۴ ← اوج در قسمت چپ است 
  ‭→ right = mid2 - 1 ‬

حالا فقط اندیس ۴ باقی مانده ← arr[4] = 8 ← پیدا شد!

اوج در اندیس: 4
```

---

### 📈 برای توابع پیوسته (مثلاً مسائل ریاضی)

برای یافتن بیشینه/کمینه توابعی مثل:
```text
f(x) = -x² + 6x + 5   → یک بیشینه دارد
```

از جستجوی سه‌گانه روی اعداد حقیقی (با دقت مشخص) استفاده می‌شود.

## ⏱️ پیچیدگی زمانی و حافظه

| توضیح | پیچیدگی | حالت |
|-------------:|------------:|--------:|
| اوج نزدیک مرزها باشد | O(1) | **بهترین حالت** |
| هر مرحله فضای جستجو را به ۲/۳ کاهش می‌دهد | O(log₃ n) ≈ O(log n) | **حالت متوسط/بدترین حالت** |
| بسته به پیاده‌سازی | O(1) تکراری<br>O(log n) بازگشتی | **پیچیدگی حافظه** |


> 📊 بنابراین:  
> `O(log₃ n)` ≈ `O(log n)` — مشابه جستجوی دودویی، اما با مقایسه‌های بیشتر در هر مرحله.

## ✅ مزایا و معایب

| ✅ مزایا | ❌ معایب |
|-------:|--------:|
| یافتن بیشینه/کمینه در داده‌های یک‌نما | فقط روی توابع/آرایه‌های یک‌نما کار می‌کند |
| مفید در مسائل بهینه‌سازی | کمی کندتر از جستجوی دودویی به خاطر دو مقایسه در هر مرحله |
| قابل استفاده برای اعداد حقیقی (با دقت) | برای جستجوی عمومی (مثل یافتن مقدار) مناسب نیست |
| عالی برای مسائل پرمحاسبه ریاضی | به ندرت در کتابخانه‌های استاندارد استفاده می‌شود |

## 🌐 زمان استفاده

◻️​ ✅ یافتن **عنصر اوج** در آرایه (مثلاً آرایه کوهستانی)

◻️​ ✅ حل مسائل **بهینه‌سازی ریاضی** (بیشینه کردن مساحت، سود و غیره)

◻️​ ✅ برنامه‌نویسی رقابتی (Codeforces، LeetCode مسائل سخت)

◻️​ ✅ بیشینه‌سازی توابع وقتی مشتق محاسبه سخت است

◻️​ ✅ اهداف آموزشی — آموزش تقسیم و غلبه فراتر از تقسیم دوتایی

> 🚫 از آن استفاده نکنید برای:
>
> ◽ جستجوی عمومی مقادیر
>
> ◽ داده‌های غیریک‌نما یا تصادفی
>
> ◽ داده‌های کوچک (جستجوی خطی ممکن است سریع‌تر باشد)

## 🔁 مقایسه با جستجوی دودویی

| جستجوی سه‌گانه | جستجوی دودویی | ویژگی |
|----------------:|---------------:|--------:|
| سه قسمت | دو قسمت | تقسیم‌بندی |
| بیشینه/کمینه در داده‌های یک‌نما | جستجوی مقدار در آرایه مرتب | بهترین مورد |
| ۲ در هر تکرار | ۱ در هر تکرار | تعداد مقایسه‌ها |
| بله (با تحمل خطا) | بله (گسسته) | قابلیت استفاده برای اعداد حقیقی؟ |
| بهینه‌سازی تخصصی | برنامه‌نویسی روزمره | کاربرد رایج |


## 💡 تشبیه دنیای واقعی

تصور کنید در حال بالا رفتن از یک کوه تنها (بدون دره یا چندین قله) هستید:

◻️​ می‌خواهید **بالاترین نقطه** را پیدا کنید

◻️​ در هر مرحله دو نقطه جلوتر را بررسی می‌کنید (نه فقط یک نقطه وسط)

◻️​ بسته به اینکه کدام بالاتر به نظر می‌رسد، تصمیم می‌گیرید به چپ، وسط یا راست بروید

همین کاری است که جستجوی سه‌گانه انجام می‌دهد — از **دو نقطه بررسی** برای هدایت به سمت اوج استفاده می‌کند.

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/search/array-based-search/ternary-search/python/) | [Java](/search/array-based-search/ternary-search/java/) | [JavaScript](/search/array-based-search/ternary-search/javascript/) | [C++](/search/array-based-search/ternary-search/cpp/) | [C#](/search/array-based-search/ternary-search/csharp/)
