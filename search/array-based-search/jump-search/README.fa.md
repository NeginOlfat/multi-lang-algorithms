اِین صفحه را به زبان‌های دیگر بخوانید: [English](/search/array-based-search/jump-search/README.md)

# 🔍 الگوریتم جستجوی پرشی

**جستجوی پرشی** (Jump Search) یک الگوریتم جستجوی کارآمد برای **آرایه‌های مرتب** است که با پرش به جلو در گام‌های ثابت (یا «بلوک‌ها») به جای بررسی هر عنصر، تعداد مقایسه‌ها را نسبت به جستجوی خطی کاهش می‌دهد.

این الگوریتم نوعی تعادل بین **جستجوی خطی** (ساده اما کند) و **جستجوی دودویی** (سریع اما پیچیده) است و در شرایطی که حرکت معکوس (بازگشت) هزینه‌بر باشد، مفید خواهد بود.

## 📚 نحوه کارکرد

1▫️​ **تعیین اندازه بلوک**:  
   اندازه بهینه پرش برابر با `‭√n‬` است، که در آن `n` طول آرایه است.

2▫️​ **پرش به جلو** به اندازه بلوک‌ها تا جایی که:
   
   ◽ عنصر ابتدایی بلوک ≤ مقدار هدف باشد
   
   ◽ عنصر ابتدایی بلوک بعدی > مقدار هدف باشد  
   *(یا به انتهای آرایه برسیم)*

3▫️​ **اجرای جستجوی خطی درون آن بلوک** برای یافتن هدف.

4▫️​ اندیس عنصر را بازگردانید، در غیر این صورت `‭-1‬` را بازگردانید.

> ✅ **شرط لازم**: آرایه ورودی **حتماً باید مرتب باشد**.

---

### 🧩 مثال

```text
آرایه:
            ‭[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]‬
هدف: 7
اندازه بلوک
 ‭(√11 ≈ 3)‬

مرحله ۱: پرش به اندیس ۳ ← مقدار = ۳ < ۷ ← ادامه  
مرحله ۲: پرش به اندیس ۶ ← مقدار = ۶ < ۷ ← ادامه  
مرحله ۳: پرش به اندیس ۹ ← مقدار = ۹ ≥ ۷ ← بازگشت به بلوک قبلی [اندیس ۶–۸]

حالا جستجوی خطی در 
‭[6, 7, 8]‬:
← ۶ ≠ ۷
← ۷ == ۷ ← پیدا شد!

اندیس: ۷
```

## ⏱️ پیچیدگی زمانی و حافظه

| توضیح | پیچیدگی | حالت |
|--------------------------------------------:|:----------:|--------------------------:|
| هدف در اولین گام بعد از پرش باشد | O(1) | **بهترین حالت** |
| پرش به اندازه ‭√n‬ گام، سپس جستجوی تا ‭√n‬ عنصر | O(√n) | **حالت متوسط/بدترین حالت** |
| از فضای اضافی ثابت استفاده می‌کند | O(1) | **پیچیدگی حافظه** |


> 💡 چرا `‭√n‬`؟  
> این اندازه کل هزینه را به حداقل می‌رساند: `‭jump_count + scan_in_block ≈ n/k + k‬`.  
> این عبارت وقتی کمینه می‌شود که `‭k = √n‬`.



## ✅ مزایا و معایب

| ✅ مزایا | ❌ معایب |
|------:|---------:|
| سریع‌تر از جستجوی خطی | کندتر از جستجوی دودویی (`O(log n)` در مقابل `O(√n)`) |
| تعداد مقایسه‌های کمتری نسبت به جستجوی خطی دارد | نیازمند داده‌های مرتب است |
| در مواقعی که حرکت به عقب هزینه‌بر است مناسب است (مثلاً در **لیست‌های پیوندی** با دسترسی تصادفی محدود) | کمتر استفاده می‌شود |
| پیاده‌سازی ساده‌ای دارد | عملکرد آن با انتخاب نادرست اندازه بلوک کاهش می‌یابد |

## 🌐 زمان استفاده از جستجوی پرشی

◻️​ ✅ داده‌ها **مرتب** باشند

◻️​ ✅ به دنبال چیزی **سریع‌تر از جستجوی خطی** ولی ساده‌تر از جستجوی دودویی باشید

◻️​ ✅ دسترسی تصادفی محدود یا هزینه‌بر باشد (مثل **لیست‌های پیوندی** — هرچند بدون ایندکس مستقیم قابل استفاده نیست)

◻️​ ✅ اهداف آموزشی — عالی برای یادگیری بهینه‌سازی از طریق جستجوی مبتنی بر بلوک

> ⚠️ برای داده‌های کوچک یا نامرتب از این روش خودداری کنید.

## 💡 تشبیه دنیای واقعی

فرض کنید دنبال نام "اسمیت" در یک دفترچه تلفن چاپ‌شده می‌گردید:

◻️ **جستجوی خطی**: از ابتدا همه‌ی نام‌ها را یکی‌یکی می‌خوانید.

◻️ **جستجوی دودویی**: دفترچه را از وسط باز می‌کنید، سپس به‌صورت نصف‌نصف ادامه می‌دهید.

◻️ **جستجوی پرشی**: هر ۱۰ صفحه یک‌بار سریع ورق می‌زنید تا از "اسمیت" عبور کنید، سپس یک بخش به عقب برمی‌گردید و صفحه‌به‌صفحه بررسی می‌کنید.

در این روش‌ها، بررسی کامل صفحات کاهش می‌یابد، در حالی که از بازگشت‌های عمیق یا منطق پیچیده پرهیز می‌شود.


## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/search/array-based-search/jump-search/python/) | [Java](/search/array-based-search/jump-search/java/) | [JavaScript](/search/array-based-search/jump-search/javascript/) | [C++](/search/array-based-search/jump-search/cpp/) | [C#](/search/array-based-search/jump-search/csharp/)