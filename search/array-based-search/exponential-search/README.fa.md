اِین صفحه را به زبان‌های دیگر بخوانید: [English](/search/array-based-search/exponential-search/README.md)

# 🔎 جستجوی نمایی – جستجوی سریع برای آرایه‌های بزرگ یا نامتناهی

**جستجوی نمایی** (که به آن **جستجوی دوبل شونده** یا **جستجوی گالُپ** هم می‌گویند) یک الگوریتم جستجوی کارآمد است که برای **آرایه‌های مرتب** طراحی شده و به‌ویژه در شرایط زیر مفید است:

◻️ اندازه آرایه **بسیار بزرگ** باشد

◻️ اندازه آن **نامشخص** باشد (مثلاً جریان‌های نامتناهی داده)

◻️ بخواهید در برخی شرایط عملکرد بهتری نسبت به جستجوی دودویی داشته باشید

این روش ترکیبی از **پرش‌های نمایی** و **دقت جستجوی دودویی** است و برای کاربردهای واقعی مثل پایگاه‌های داده، فایل سیستم‌ها و جریان داده‌ها ایده‌آل است.

## 📚 نحوه کارکرد

جستجوی نمایی در **دو مرحله** انجام می‌شود:

### 🔁 مرحله ۱: یافتن بازه
◻️ با یک زیرآرایه به اندازه ۱ شروع کنید (`‭arr[0..1]‬`)

◻️ آخرین عنصر را با مقدار هدف مقایسه کنید

◻️ بازه را دو برابر کنید (`‭1 → 2 → 4 → 8 → ...‬`) تا زمانی که بلوکی پیدا کنید :
  
  ◽ که `‭arr[i] >= target‬`

  ◽ یا به انتهای آرایه برسید

این کار به سرعت یک **بازه [i/2, i]** پیدا می‌کند که ممکن است شامل هدف باشد.

### 🔍 مرحله ۲: جستجوی دودویی درون بازه
◻️ **جستجوی دودویی** را در بازه مشخص‌شده انجام دهید

◻️ اندیس را در صورت پیدا شدن بازگردانید؛ در غیر این صورت `‭-1‬`

> ✅ **شرط لازم**: آرایه ورودی **حتماً باید مرتب باشد**

### 🧩 مثال

```text
آرایه:
 ‭[10, 20, 30, 40, 50, 60, 70, 80, 90, 100]‬
هدف: 70

مرحله ۱: پرش‌های نمایی
- بررسی اندیس ۰ ← ۱۰ < ۷۰ ← ادامه
- پرش به اندیس ۱ ← ۲۰ < ۷۰
- پرش به اندیس ۲ ← ۳۰ < ۷۰
- پرش به اندیس ۴ ← ۵۰ < ۷۰
- پرش به اندیس ۸ ← ۹۰ ≥ ۷۰ ← بازه [۴, ۸] پیدا شد

مرحله ۲: جستجوی دودویی در ‭[50, 60, 70, 80, 90]‬
← ۷۰ در اندیس ۶ پیدا شد

نتیجه: اندیس ۶
```

## ⏱️ پیچیدگی زمانی و حافظه

| توضیح | پیچیدگی | حالت |
|-------------:|:-----------:|--------------------:|
| هدف اولین عنصر باشد | O(1) | **بهترین حالت** |
| یک مرحله log(n) برای یافتن بازه + یکی برای جستجوی دودویی | O(log n) | **حالت متوسط/بدترین حالت** |
| نسخه تکراری از فضای ثابت استفاده می‌کند | O(1) | **پیچیدگی حافظه** |


> 💡 علیرغم دو مرحله، همچنان **O(log n)** است — دقیقاً مثل جستجوی دودویی  
> اما اغلب در عمل **سریع‌تر** است چون در مراحل اولیه مقایسه‌های کمتری انجام می‌دهد

## ✅ مزایا و معایب

| ✅ مزایا | ❌ معایب |
|-------:|--------:|
| زمان O(log n) روی آرایه‌های مرتب | نیازمند داده‌های مرتب است |
| کارآمد برای **آرایه‌های بزرگ یا با اندازه نامشخص** | کمی پیچیده‌تر از جستجوی دودویی است |
| عالی برای **جریان‌های نامتناهی** یا داده‌های بدون حد | برای داده‌های کوچک مفید نیست |
| در **حالت گالُپ** الگوریتم `timsort` پایتون استفاده می‌شود | برای جستجوی تکی در آرایه‌های کوچک بیش از حد است

## 🌐 زمان استفاده

◻️ ✅ جستجو در **آرایه‌های مرتب بسیار بزرگ**

◻️ ✅ کار با **جریان‌های داده نامحدود یا نامتناهی** (مثلاً لاگ‌ها، داده‌های سنسور)

◻️ ✅ پیاده‌سازی **الگوریتم‌های ادغام** (مثل timsort)

◻️ ✅ سیستم‌های حساس به عملکرد که کارایی میانگین مهم است

◻️ ✅ اهداف آموزشی — نشان‌دهنده طراحی الگوریتم ترکیبی

> 🚫 برای آرایه‌های کوچک از آن استفاده نکنید — هزینه اضافی آن ارزشش را ندارد

## 🔁 مقایسه با جستجوی دودویی

| جستجوی نمایی | جستجوی دودویی | ویژگی |
|--------------------:|---------------:|--------:|
| از ابتدا شروع می‌کند | وسط کل آرایه | نقطه شروع |
| حتی اگر اندازه نامشخص باشد کار می‌کند | اندازه آرایه شناخته شده است | فرض |
| آرایه‌های پویا یا بسیار بزرگ | آرایه‌های مرتب با اندازه ثابت | بهترین مورد |
| جستجو/مرتب‌سازی پیشرفته | جستجوی عمومی | کاربرد واقعی |
| منطق دو مرحله‌ای | ساده | پیاده‌سازی |


> این را می‌توان **"جستجوی دودویی با قدرت فوق‌العاده"** دانست — نیازی به دانستن انتهای آرایه ندارد!

## 💡 تشبیه دنیای واقعی

تصور کنید در کتابی با **طول نامشخص** به دنبال صفحه ۷۰۰ هستید:

◻️ **جستجوی دودویی**: ابتدا باید تعداد کل صفحات را بداند ← نمی‌تواند شروع کند

◻️ **جستجوی نمایی**: به صفحه ۱، ۲، ۴، ۸، ۱۶، ۳۲، ۶۴، ۱۲۸، ۲۵۶، ۵۱۲، ۱۰۲۴ می‌رود...  
  ← متوجه می‌شود ۱۰۲۴ > ۷۰۰ ← حالا بازه [۵۱۲–۱۰۲۴] را می‌داند ← جستجوی دودویی درون آن ← پیدا شد!


## 🔄 چرا "نمایی"؟

چون اندازه بازه جستجو به صورت **نمایی** افزایش می‌یابد:
```
اندیس بررسی شده:
              ‭1 → 2 → 4 → 8 → 16 → 32 → ...‬
اندازه بازه:
        ‭1 → 2 → 4 → 8 → 16 → 32 → ... = 2^k‬
```

بنابراین فقط در **log₂(n)** مرحله به انتهای آرایه‌ای با اندازه `n` می‌رسد.

## 💻 مراحل بعدی

زبان مورد نظر خود را برای مشاهده پیاده‌سازی انتخاب کنید:

[Python](/search/array-based-search/exponential-search/python/) | [Java](/search/array-based-search/exponential-search/java/) | [JavaScript](/search/array-based-search/exponential-search/javascript/) | [C++](/search/array-based-search/exponential-search/cpp/) | [C#](/search/array-based-search/exponential-search/csharp/)